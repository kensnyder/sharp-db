{"version":3,"sources":["Db/Db.js","Parser/Parser.js","Select/Select.js","entry.js"],"names":["instances","Db","constructor","config","mocks","env","process","host","hostname","DB_HOSTNAME","user","username","DB_USERNAME","password","DB_PASSWORD","database","DB_DATABASE","port","DB_PORT","encoding","DB_ENCODING","push","factory","instance","connect","connection","mysql","createConnection","err","fatal","Error","code","sqlMessage","connectOnce","end","Promise","resolve","reject","destroy","endAll","all","map","db","destroyAll","forEach","select","sql","bindVars","options","bindArgs","lastQuery","query","error","results","fields","lastFields","selectHash","key","name","val","hash","result","selectList","list","selectGrouped","groupField","selectIndexed","indexField","selectFirst","selectValue","selectExists","then","Boolean","insert","insertId","update","changedRows","delete","selectFrom","table","criteria","extra","Array","isArray","escFields","field","quote","length","join","buildWheres","trim","selectId","id","selectByKey","selectUuid","uuid","column","value","escTable","escColumn","selectOrCreate","newValues","insertInto","values","escape","insertSql","insertIntoOnDuplicateKeyUpdate","fieldsSql","sets","setSql","lastInsertId","affected","affectedRows","updateTable","set","where","deleteFrom","limit","wheres","clauses","hasOwnProperty","buildWhere","operator","split","toUpperCase","args","arg","replace","$0","$1","escapeQuoteless","slice","identifier","test","quoted","escapeId","tpl","supported","functions","templateData","variables","toSql","s","variable","i","mock","when","data","cb","RegExp","Parser","_stripComments","_extractSubqueries","subqueries","extractor","placeholder","_injectSubqueries","replacer","mapper","clause","_columns","_joins","_wheres","_havings","_split","parse","rawSql","stripped","expressions","rawKeyword","keyword","handler","_handleSelect","columns","buffer","optionRegex","match","option","indexOf","_handleFrom","_handleJoin","innerJoin","_handleInnerJoin","_handleLeftJoin","leftJoin","_handleLeftOuterJoin","leftOuterJoin","_handleRightJoin","rightJoin","_handleRightOuterJoin","rightOuterJoin","_handleCrossJoin","crossJoin","_handleFullJoin","fullJoin","_handleFullOuterJoin","fullOuterJoin","_handleWhere","_handleConditions","_handleHaving","type","andGroup","orPieces","fn","orFn","_handleGroupBy","groupBy","_handleOrderBy","orderBy","_handleLimit","_handleOffset","offset","Select","reset","init","toString","lines","_options","_tables","_groupBys","_orderBys","_page","_limit","_offset","filter","normalized","prop","_hasOne","_belongsTo","_hasMany","_habtm","_bound","hasOne","thisProperty","thatTableAndColumn","belongsTo","hasMany","habtm","idsColumn","matchJoinFirst","matchJoinSecond","_","joinTable","throughTable","foreignColumn","hasAndBelongsToMany","bind","unbind","p","undefined","fetch","records","_spliceHasOnes","_spliceBelongsTos","_spliceHasManys","_spliceHabtms","fetchFirst","fetchHash","fetchValue","fetchIndexed","byField","rs","indexed","r","fetchGrouped","grouped","getClone","copy","getFoundRowsQuery","countExpr","clone","subquery","getFoundRowsSql","normalize","foundRows","spec","thisColumn","ids","thisPropery","columnNames","columnName","optionExpression","tableName","from","expression","unjoin","t","_conditions","collection","numArgs","$2","parts","shift","likeMatch","toLocaleUpperCase","to","quoteless","inVals","joined","v","whereBetween","twoValueArray","orWhere","conditions","condition","having","orHaving","sortField","mapNames","direction","num","Number","page","escaped"],"mappings":"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","file":"index.js","sourceRoot":"../src","sourcesContent":["import forOwn from 'lodash.forown';\nimport mysql from 'mysql2';\n\n/**\n * A list of all the Db Instances that have been created\n * @type {Array}\n */\nconst instances = [];\n\n/**\n * Simple database class for mysql\n */\nexport class Db {\n\t/**\n\t * Connection options including host, login, password, encoding, database\n\t * @param {Object} config  Configuration object\n\t */\n\tconstructor(config = {}) {\n\t\tthis.mocks = [];\n\t\tconst env =\n\t\t\ttypeof process === 'object' && typeof process.env === 'object'\n\t\t\t\t? process.env\n\t\t\t\t: {};\n\t\tthis.config = {\n\t\t\thost: config.hostname || env.DB_HOSTNAME || '127.0.0.1',\n\t\t\tuser: config.username || env.DB_USERNAME || 'root',\n\t\t\tpassword: config.password || env.DB_PASSWORD || '',\n\t\t\tdatabase: config.database || env.DB_DATABASE || 'platform',\n\t\t\tport: config.port || env.DB_PORT || 3306,\n\t\t\tencoding: config.encoding || env.DB_ENCODING || 'utf-8',\n\t\t};\n\t\tinstances.push(this);\n\t}\n\n\t/**\n\t * Create a new QuickDb instance or return the last used one\n\t * @param {Object} [config]  In the format required by mysql js\n\t * @return {Db}\n\t */\n\tstatic factory(config = {}) {\n\t\tif (!Db.instance) {\n\t\t\tDb.instance = new Db(config);\n\t\t}\n\t\treturn Db.instance;\n\t}\n\n\t/**\n\t * Make a new connection to MySQL\n\t */\n\tconnect() {\n\t\tthis.connection = mysql.createConnection(this.config);\n\t\tthis.connection.connect(err => {\n\t\t\tif (err && err.fatal) {\n\t\t\t\tthrow new Error(`[${err.code}] ${err.sqlMessage}`);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Make a new connection to MySQL if not already connected\n\t */\n\tconnectOnce() {\n\t\tif (!this.connection) {\n\t\t\tthis.connect();\n\t\t}\n\t}\n\n\t/**\n\t * Close this connection to the database\n\t * @return {Promise}  Resolves when connection has been closed\n\t */\n\tend() {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (this.connection && this.connection.end) {\n\t\t\t\tthis.connection.end(err => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Destroy the connection to the database\n\t * @return {Db}\n\t */\n\tdestroy() {\n\t\tif (this.connection && this.connection.destroy) {\n\t\t\tthis.connection.destroy();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Close all connections to the database\n\t * @return {Promise}  Resolves when all connections have been closed\n\t */\n\tstatic endAll() {\n\t\treturn Promise.all(instances.map(db => db.end()));\n\t}\n\n\t/**\n\t * Destroy all connections to the database\n\t * @return {Db}\n\t */\n\tstatic destroyAll() {\n\t\tinstances.forEach(db => db.destroy());\n\t\treturn Db;\n\t}\n\n\t// /**\n\t//  * Run a list of semicolon-delimited queries\n\t//  * @see https://www.npmjs.com/package/mysql#multiple-statement-queries\n\t//  * @param {String} sql\n\t//  * @param int|string $bindVar1  The value to bind to the first question mark\n\t//  * @param int|string $bindVarN  The value to bind to the nth question mark\n\t//  * @return {Array}|bool\n\t//  */\n\t// multiQuery(/*$sql, $bindVar1, $bindVarN*/) {\n\t// \tif (!$this->_connectOnce()) {\n\t// \t\treturn false;\n\t// \t}\n\t// \t$sql = $this->bindArgs(func_get_args());\n\t// \t$ok = mysqli_multi_query($this->_dbh, $sql);\n\t// \tif (!$ok) {\n\t// \t\treturn false;\n\t// \t}\n\t// \t$fetch = \"mysqli_fetch_$this->fetchMode\";\n\t// \t$resultSets = [];\n\t// \twhile(1) {\n\t// \t\t/* get first result set */\n\t// \t\t$resultSet = [];\n\t// \t\tif (($result = mysqli_store_result($this->_dbh))) {\n\t// \t\t\twhile (($row = $fetch($result))) {\n\t// \t\t\t\t$resultSet[] = $row;\n\t// \t\t\t}\n\t// \t\t\tmysqli_free_result($result);\n\t// \t\t}\n\t// \t\t$resultSets[] = $resultSet;\n\t// \t\tif (!mysqli_next_result($this->_dbh)) {\n\t// \t\t\tbreak;\n\t// \t\t}\n\t// \t}\n\t// \treturn $resultSets;\n\t// }\n\n\t/**\n\t * Return result rows for the given SELECT statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Object[]>}\n\t */\n\tselect(sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(\n\t\t\t\toptions,\n\t\t\t\t(error, results, fields) => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.lastFields = fields;\n\t\t\t\t\t\tresolve(results);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Return result array as col1 => col2 pairs for the given SELECT statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Object>}\n\t */\n\tselectHash(sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(\n\t\t\t\toptions,\n\t\t\t\tbindVars,\n\t\t\t\t(error, results, fields) => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.lastFields = fields;\n\t\t\t\t\t\tconst key = fields[0].name;\n\t\t\t\t\t\tconst val = fields[1].name;\n\t\t\t\t\t\tconst hash = {};\n\t\t\t\t\t\tresults.forEach(result => {\n\t\t\t\t\t\t\thash[result[key]] = result[val];\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresolve(hash);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Return result array as col1 => col2 pairs for the given SELECT statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Object>}\n\t */\n\tselectList(sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(\n\t\t\t\toptions,\n\t\t\t\t(error, results, fields) => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.lastFields = fields;\n\t\t\t\t\t\tconst name = fields[0].name;\n\t\t\t\t\t\tconst list = [];\n\t\t\t\t\t\tresults.forEach(result => list.push(result[name]));\n\t\t\t\t\t\tresolve(list);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Return records all grouped by one of the column's values\n\t * @param {String} groupField  The name of the field to group by\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Array>}\n\t */\n\tselectGrouped(groupField, sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(\n\t\t\t\toptions,\n\t\t\t\t(error, results, fields) => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.lastFields = fields;\n\t\t\t\t\t\tconst hash = {};\n\t\t\t\t\t\tresults.forEach(result => {\n\t\t\t\t\t\t\tif (!hash[result[groupField]]) {\n\t\t\t\t\t\t\t\thash[result[groupField]] = [];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\thash[result[groupField]].push(result);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresolve(hash);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Return records all indexed by one of the column's values\n\t * @param {String} indexField  The name of the field to index by\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Array>}\n\t */\n\tselectIndexed(indexField, sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(\n\t\t\t\toptions,\n\t\t\t\t(error, results, fields) => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.lastFields = fields;\n\t\t\t\t\t\tconst hash = {};\n\t\t\t\t\t\tresults.forEach(result => {\n\t\t\t\t\t\t\thash[result[indexField]] = result;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresolve(hash);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Return first result row for the given SELECT statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Object>}\n\t */\n\tselectFirst(sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(\n\t\t\t\toptions,\n\t\t\t\t(error, results, fields) => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.lastFields = fields;\n\t\t\t\t\t\tresolve(results[0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Return first column value for the first result row for the given SELECT statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Number|String>}\n\t */\n\tselectValue(sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(\n\t\t\t\toptions,\n\t\t\t\t(error, results, fields) => {\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.lastFields = fields;\n\t\t\t\t\t\tconst name = fields[0].name;\n\t\t\t\t\t\tresolve(results[0][name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\t/**\n\t * Run the given SELECT statement wrapped in a SELECT EXISTS query\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Boolean>}  True if it exists, false otherwise\n\t */\n\tselectExists(sql, ...bindVars) {\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\toptions.sql = `SELECT EXISTS (${options.sql}) AS does_it_exist`;\n\t\treturn this.selectValue(options).then(Boolean, err => err);\n\t}\n\n\t/**\n\t * Run the given INSERT statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Number>}  The id of the last inserted record\n\t */\n\tinsert(sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(options, (error, results) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(results.insertId);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Run the given UPDATE statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Number>}  The number of rows affected by the statement\n\t */\n\tupdate(sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(options, (error, results) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(results.changedRows);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Run the given DELETE statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Array>}\n\t */\n\tdelete(sql, ...bindVars) {\n\t\treturn this.update(sql, ...bindVars);\n\t}\n\n\t/**\n\t * Build a SELECT statement and return result rows\n\t * @param {String} table  The name of the table\n\t * @param {Array} fields  An array of field names to select\n\t * @param {Object} criteria  Params to construct the WHERE clause\n\t * @param {String} extra  Additional raw SQL such as GROUP BY, ORDER BY, or LIMIT\n\t * @return {Promise<Array>}  The result rows\n\t */\n\tselectFrom(table, fields = [], criteria = {}, extra = '') {\n\t\tif (!Array.isArray(fields)) {\n\t\t\tthrow new Error('Db.selectFrom fields must be an array');\n\t\t}\n\t\tif (typeof criteria !== 'object') {\n\t\t\tthrow new Error('Db.selectFrom criteria must be an array');\n\t\t}\n\t\tthis.connectOnce();\n\t\tconst escFields = fields.map(field => this.quote(field));\n\t\tconst escFieldsString = fields.length ? escFields.join(', ') : '*';\n\t\tconst escTable = this.quote(table);\n\t\tconst escWhere = this.buildWheres(criteria) || '1';\n\t\tconst sql = `SELECT ${escFieldsString} FROM ${escTable} WHERE ${escWhere} ${extra}`.trim();\n\t\treturn this.select(sql);\n\t}\n\n\t/**\n\t * Select the record with the given id\n\t * @param {String} table  The name of the table from which to select\n\t * @param {String} id  The value of the id column\n\t * @return {Promise<Number>}\n\t */\n\tselectId(table, id) {\n\t\treturn this.selectByKey(table, 'id', id);\n\t}\n\n\t/**\n\t * Select the record with the given UUID\n\t * @param {String} table  The name of the table from which to select\n\t * @param {String} uuid  The value of the uuid column\n\t * @return {Promise<String>}\n\t */\n\tselectUuid(table, uuid) {\n\t\treturn this.selectByKey(table, 'uuid', uuid);\n\t}\n\n\t/**\n\t * Select the record with the given UUID\n\t * @param {String} table  The name of the table from which to select\n\t * @param {String} column  The name of the column from which to select\n\t * @param {String} value  The value of the record for that column\n\t * @return {Promise<Object>}\n\t */\n\tselectByKey(table, column, value) {\n\t\tconst escTable = this.quote(table);\n\t\tconst escColumn = this.quote(column);\n\t\treturn this.selectFirst(\n\t\t\t`SELECT * FROM ${escTable} WHERE ${escColumn} = ?`,\n\t\t\tvalue\n\t\t);\n\t}\n\n\t/**\n\t * Find a record or add a new one\n\t * @param {String} table  The name of the table from which to select\n\t * @param {Object} criteria  Criteria by which to find the row\n\t * @param {Object} newValues  The values to use to insert if the record doesn't exist\n\t * @return {Promise<Number>}  The existing id or the new id\n\t */\n\tselectOrCreate(table, criteria, newValues = {}) {\n\t\treturn this.selectFrom(table, [], criteria).then(\n\t\t\tresults => {\n\t\t\t\tif (results.length > 0) {\n\t\t\t\t\treturn results[0];\n\t\t\t\t} else {\n\t\t\t\t\treturn this.insertInto(table, newValues);\n\t\t\t\t}\n\t\t\t},\n\t\t\terr => err\n\t\t);\n\t}\n\n\t/**\n\t * Build an INSERT statement and run it\n\t * @param {String} table  The name of the table\n\t * @param {Object} insert  column-value pairs to insert\n\t * @return {Promise<Number>}  Id of the last inserted record\n\t */\n\tinsertInto(table, insert) {\n\t\t// build insert expression\n\t\tconst fields = [];\n\t\tconst values = [];\n\t\tforOwn(insert, (value, field) => {\n\t\t\tfields.push(this.quote(field));\n\t\t\tvalues.push(mysql.escape(value));\n\t\t});\n\t\tif (fields.length === 0) {\n\t\t\tthrow new Error(\n\t\t\t\t'Db.insertIntoOnDuplicateKeyUpdate requires a non-empty insert Object'\n\t\t\t);\n\t\t}\n\t\tconst escTable = this.quote(table);\n\t\tconst fieldsSql = fields.join(',');\n\t\tconst valuesSql = values.join(',');\n\t\tconst insertSql = `INSERT INTO ${escTable} (${fieldsSql}) VALUES (${valuesSql})`;\n\t\treturn this.insert(insertSql);\n\t}\n\n\t/**\n\t * Run an \"INSERT INTO ... ON DUPLICATE KEY UPDATE\" query where\n\t * if a key conflicts, update the given fields\n\t * @param {String} table  The name of the table\n\t * @param {Object} insert  An array with column => value pairs for insertion\n\t * @param {Object} update  An array with column => value pairs for update\n\t * @return {Promise<Object>} result\n\t * @property {Number} result.lastInsertId  The id of the last inserted or updated record\n\t * @property {Number} result.affected  The number of rows updated (if any)\n\t */\n\tinsertIntoOnDuplicateKeyUpdate(table, insert, update) {\n\t\tthis.connectOnce();\n\t\t// build insert expression\n\t\tconst fields = [];\n\t\tconst values = [];\n\t\tforOwn(insert, (value, field) => {\n\t\t\tfields.push(this.quote(field));\n\t\t\tvalues.push(mysql.escape(value));\n\t\t});\n\t\tif (fields.length === 0) {\n\t\t\tthrow new Error(\n\t\t\t\t'Db.insertIntoOnDuplicateKeyUpdate requires a non-empty insert Object'\n\t\t\t);\n\t\t}\n\t\ttable = this.quote(table);\n\t\tconst fieldsSql = fields.join(',');\n\t\tconst valuesSql = values.join(',');\n\t\tconst insertSql = `INSERT INTO ${table} (${fieldsSql}) VALUES (${valuesSql})`;\n\t\t// build update expression\n\t\tconst sets = [];\n\t\tforOwn(update, (value, field) => {\n\t\t\tsets.push(this.quote(field) + '=' + mysql.escape(value));\n\t\t});\n\t\tif (sets.length === 0) {\n\t\t\tthrow new Error(\n\t\t\t\t'Db.insertIntoOnDuplicateKeyUpdate requires a non-empty update Object'\n\t\t\t);\n\t\t}\n\t\tconst setSql = sets.join(',');\n\t\t// combine\n\t\tconst sql = `${insertSql} ON DUPLICATE KEY UPDATE ${setSql}`;\n\t\t// run\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(sql, values, (error, results) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve({\n\t\t\t\t\t\tlastInsertId: results.insertId,\n\t\t\t\t\t\taffected: results.affectedRows,\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Build an UPDATE statement and run it\n\t * @param {String} table  The name of the table\n\t * @param {Object} set  An array of column => value pairs to update\n\t * @param {Object} where  Params to construct the WHERE clause\n\t * @return {Promise<Number>}  Number of rows affected\n\t */\n\tupdateTable(table, set, where = {}) {\n\t\tthis.connectOnce();\n\t\tconst escTable = this.quote(table);\n\t\tconst escWhere = this.buildWheres(where);\n\t\tconst sql = `UPDATE ${escTable} SET ? WHERE ${escWhere}`;\n\t\treturn this.select(sql, set);\n\t}\n\n\t/**\n\t * Construct a delete query and run\n\t * @param {String} table  The name of the table from which to delete\n\t * @param {Object} where  WHERE conditions on which to delete\n\t * @param {Number} limit  Limit deletion to this many records\n\t * @return {Promise<Number>}  Number of affected rows\n\t */\n\tdeleteFrom(table, where, limit = null) {\n\t\tthis.connectOnce();\n\t\tconst escTable = this.quote(table);\n\t\tconst escWhere = this.buildWheres(where);\n\t\tlet sql = `DELETE FROM ${escTable} WHERE ${escWhere}`;\n\t\tif (limit > 0) {\n\t\t\tsql = `${sql}LIMIT ${limit}`;\n\t\t}\n\t\treturn this.delete(sql);\n\t}\n\n\t/**\n\t * Build a where clause from an object of field-value pairs\n\t * @param {Object} wheres  An object with field-value pairs (field may be field space operator)\n\t * @return {String}\n\t */\n\tbuildWheres(wheres) {\n\t\tconst clauses = [];\n\t\tfor (const field in wheres) {\n\t\t\tif (!wheres.hasOwnProperty(field)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclauses.push(this.buildWhere(field, wheres[field]));\n\t\t}\n\t\treturn clauses.length ? clauses.join(' AND ') : '1';\n\t}\n\n\t/**\n\t * Construct where clause element from the given field and value\n\t * @param {String} field  The field or field space operator\n\t * @param {*} value  The value to bind\n\t * @return {String}\n\t * @example\n\t * db.buildWhere('start_date BETWEEN', array('2012-01-01','2013-01-01'));\n\t * db.buildWhere('start_date >', '2013-01-01');\n\t * db.buildWhere('start_date !=', '2013-01-01');\n\t * db.buildWhere('start_date', null); // `start_date` IS NULL\n\t * db.buildWhere('start_date !=', null); // `start_date` IS NOT NULL\n\t * db.buildWhere('id', array(1,2,3)); // id IN (1,2,3)\n\t * db.buildWhere('id !=', array(1,2,3)); // id NOT IN (1,2,3)\n\t */\n\tbuildWhere(field, value) {\n\t\tlet [name, operator] = field.split(' ');\n\t\tname = this.quote(name);\n\t\toperator = operator ? operator.toUpperCase() : '=';\n\t\tif (operator === 'BETWEEN') {\n\t\t\tconst val0 = mysql.escape(value[0]);\n\t\t\tconst val1 = mysql.escape(value[1]);\n\t\t\treturn `${name} BETWEEN ${val0} AND ${val1}`;\n\t\t} else if (value === null) {\n\t\t\treturn operator === '=' ? `${name} IS NULL` : `${name} IS NOT NULL`;\n\t\t} else if (Array.isArray(value)) {\n\t\t\tconst values = value.map(val => mysql.escape(val));\n\t\t\treturn operator === '=' || operator === 'IN'\n\t\t\t\t? `${name} IN(${values})`\n\t\t\t\t: `${name} NOT IN(${values})`;\n\t\t}\n\t\tconst escVal = mysql.escape(value);\n\t\treturn `${name} ${operator} ${escVal}`;\n\t}\n\n\t/**\n\t * Bind an array of arguments to a query\n\t * @param {String} sql  The base SQL query\n\t * @param {Array} args  An array of values to bind\n\t * @return {String}\n\t * @example\n\t * db.select('SELECT * FROM users WHERE id = ?', 100);\n\t * db.bindArgs(array('SELECT * FROM users WHERE id = ?', 100)); // SELECT * FROM users WHERE id = '100'\n\t * db.select('SELECT * FROM users WHERE id = :id', array('id'=>100));\n\t * db.bindArgs(array('SELECT * FROM users WHERE id = :id', array('id'=>100))); // SELECT * FROM users WHERE id = '100'\n\t */\n\tbindArgs(sql, args) {\n\t\tconst options = typeof sql == 'object' ? sql : { sql };\n\t\tif (typeof options.sql !== 'string') {\n\t\t\toptions.sql = '';\n\t\t}\n\t\tif (!Array.isArray(args)) {\n\t\t\treturn options;\n\t\t}\n\t\targs.forEach(arg => {\n\t\t\tif (arg && typeof arg === 'object' && !Array.isArray(arg)) {\n\t\t\t\toptions.sql = options.sql.replace(/:([\\w_]+)/g, ($0, $1) => {\n\t\t\t\t\tif (arg.hasOwnProperty($1)) {\n\t\t\t\t\t\treturn mysql.escape(arg[$1]);\n\t\t\t\t\t}\n\t\t\t\t\treturn $0;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\toptions.sql = options.sql.replace('?', mysql.escape(arg));\n\t\t\t}\n\t\t});\n\t\treturn options;\n\t}\n\n\t/**\n\t * Escape a value for use in a raw query and surround with apostrophes\n\t * @param {*} value  The value to escape\n\t * @return {String}\n\t */\n\tescape(value) {\n\t\treturn mysql.escape(value);\n\t}\n\n\t/**\n\t * Escape a value for use in a raw query without apostrophes\n\t * @param {*} value  The value to escape\n\t * @return {String}\n\t */\n\tescapeQuoteless(value) {\n\t\treturn mysql.escape(value).slice(1, -1);\n\t}\n\n\t/**\n\t * Escape an identifier such as a table or column\n\t * @param identifier\n\t * @return {*}\n\t */\n\tquote(identifier) {\n\t\tif (identifier === '*') {\n\t\t\treturn identifier;\n\t\t}\n\t\tif (/[`()]/.test(identifier)) {\n\t\t\treturn identifier;\n\t\t}\n\t\tlet quoted = mysql.escapeId(identifier);\n\t\tif (/\\.`\\*`$/.test(quoted)) {\n\t\t\tquoted.slice(0, -3) + '*';\n\t\t}\n\t\treturn quoted;\n\t}\n\n\t/**\n\t * Return an object with query methods to run on template literals\n\t * (backticked strings) where interpolated strings are automatically escaped\n\t * @example\n\t * const query = db.tpl();\n\t * const users = await query.select`SELECT * FROM users WHERE id IN(${userIds})`;\n\t * const count = await query.selectValue`SELECT COUNT(*) FROM users WHERE is_active = ${isActive}`;\n\t * @return {Object}  Object with query methods\n\t * @property {Function} select  Same as Db#select()\n\t * @property {Function} selectFirst  Same as Db#selectFirst()\n\t * @property {Function} selectList  Same as Db#selectList()\n\t * @property {Function} selectHash  Same as Db#selectHash()\n\t * @property {Function} selectValue  Same as Db#selectValue()\n\t * @property {Function} insert  Same as Db#insert()\n\t * @property {Function} update  Same as Db#update()\n\t * @property {Function} delete  Same as Db#delete()\n\t */\n\ttpl() {\n\t\tfunction toSql(templateData, variables) {\n\t\t\tlet s = templateData[0];\n\t\t\tvariables.forEach((variable, i) => {\n\t\t\t\ts += mysql.escape(variable);\n\t\t\t\ts += templateData[i + 1];\n\t\t\t});\n\t\t\treturn s;\n\t\t}\n\t\tconst supported = [\n\t\t\t'select',\n\t\t\t'selectFirst',\n\t\t\t'selectList',\n\t\t\t'selectHash',\n\t\t\t'selectValue',\n\t\t\t'insert',\n\t\t\t'update',\n\t\t\t'delete',\n\t\t];\n\t\tconst functions = {};\n\t\tsupported.forEach(name => {\n\t\t\tfunctions[name] = (templateData, ...variables) => {\n\t\t\t\treturn this[name](toSql(templateData, variables));\n\t\t\t};\n\t\t});\n\t\treturn functions;\n\t}\n\n\t/**\n\t * Instruct Db to return the given data when the query matches the given\n\t * pattern\n\t * @param {String|RegExp|Function} when  The pattern to match\n\t * @param {*} data  The data to return\n\t * @return {Db}\n\t */\n\tmock(when, data) {\n\t\tif (this.mocks.length === 0) {\n\t\t\tthis.connection = {\n\t\t\t\tconnect: function() {},\n\t\t\t\tquery: function(options, values, cb) {\n\t\t\t\t\tfor (mock of this.mocks) {\n\t\t\t\t\t\tconst { when, data } = mock;\n\t\t\t\t\t\tif (typeof when === 'string') {\n\t\t\t\t\t\t\tif (options.sql === when) {\n\t\t\t\t\t\t\t\tcb(data);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (when instanceof RegExp) {\n\t\t\t\t\t\t\tif (when.test(options.sql)) {\n\t\t\t\t\t\t\t\tcb(data);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (typeof when === 'function') {\n\t\t\t\t\t\t\tif (when(options.sql)) {\n\t\t\t\t\t\t\t\tcb(data);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcb(data);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\tthis.mocks.push({ when, data });\n\t\treturn this;\n\t}\n}\n","import capitalize from 'lodash.capitalize';\nimport camelCase from 'lodash.camelcase';\nimport upperFirst from 'lodash.upperfirst';\nimport trim from 'lodash.trim';\n\n/**\n * Parse SQL and populate onto a Select query object\n */\nexport class Parser {\n\t/**\n\t * Create a new instance\n\t * @param {Select} query  A Select object on which to build parsed conditions\n\t */\n\tconstructor(query) {\n\t\tthis.query = query;\n\t}\n\n\t/**\n\t * Strip single-line and multi-line comment blocks\n\t * @param {String} sql  The SQL string\n\t * @return {String}\n\t */\n\t_stripComments(sql) {\n\t\t// multiline comments\n\t\tsql = sql.replace(/\\/\\*[\\s\\S]*?\\*\\//g, '');\n\t\t// single line comments -- dashes\n\t\tsql = sql.replace(/--([\\r\\n]|\\s+[^\\r\\n]+[\\r\\n])/g, '');\n\t\t// single line comments #hashes\n\t\tsql = sql.replace(/#[^\\r\\n]+[\\r\\n]/g, '');\n\t\treturn sql;\n\t}\n\n\t/**\n\t * Before splitting into SQL clauses, extract some regex-able subqueries\n\t * @param {String} sql  The unparsed sql string\n\t * @return {Object}  An array with new sql and subqueries\n\t */\n\t_extractSubqueries(sql) {\n\t\tconst subqueries = {};\n\t\tlet i = 0;\n\t\tconst extractor = $0 => {\n\t\t\tconst placeholder = `~~SUBQUERY_${i++}~~`;\n\t\t\tsubqueries[placeholder] = $0;\n\t\t\treturn placeholder;\n\t\t};\n\t\t// subselect in FROM clause\n\t\tsql = sql.replace(/\\(\\s*SELECT\\s+.+\\)\\s+AS\\s+[^\\s,]+/, extractor);\n\t\t// IF() in FROM clause\n\t\tsql = sql.replace(/\\bIF\\s*\\(.+\\)\\s+AS\\s+[^\\s,]+/, extractor);\n\t\t// IN (SELECT *) in JOINs, WHERE or HAVING\n\t\tsql = sql.replace(/\\bIN\\s*\\(SELECT\\s.+?\\)/, extractor);\n\t\treturn { sql, subqueries };\n\t}\n\n\t/**\n\t * Inject column subqueries back into this object\n\t * @param {Object} subqueries  The lookup of extracted subqueries\n\t */\n\t_injectSubqueries(subqueries) {\n\t\tconst replacer = $0 => {\n\t\t\treturn subqueries[$0] || $0;\n\t\t};\n\t\tconst mapper = clause => {\n\t\t\treturn clause.replace(/~~SUBQUERY_\\d+~~/g, replacer);\n\t\t};\n\t\tthis.query._columns = this.query._columns.map(replacer);\n\t\tthis.query._joins = this.query._joins.map(mapper);\n\t\tthis.query._wheres = this.query._wheres.map(mapper);\n\t\tthis.query._havings = this.query._havings.map(mapper);\n\t}\n\n\t/**\n\t * Split SQL into clauses (used by ::parse())\n\t * @param {String} sql  The SQL to split\n\t * @return {String[]}\n\t */\n\t_split(sql) {\n\t\tconst splitter = /\\b(SELECT|FROM|(?:INNER |LEFT OUTER |RIGHT OUTER |LEFT |RIGHT |CROSS |FULL |FULL OUTER )JOIN|WHERE|GROUP BY|HAVING|ORDER BY|LIMIT|OFFSET)\\b/i;\n\t\treturn sql.split(splitter);\n\t}\n\n\t/**\n\t * Get a QuickSelect object representing the given SQL SELECT statement\n\t * @param {String} rawSql  The raw SQL for the SELECT statement\n\t * @return {Boolean}\n\t */\n\tparse(rawSql) {\n\t\tconst stripped = this._stripComments(rawSql);\n\t\tconst { sql, subqueries } = this._extractSubqueries(stripped);\n\t\tconst expressions = this._split(sql);\n\t\tlet i = 1;\n\t\twhile (i < expressions.length) {\n\t\t\tconst rawKeyword = expressions[i++].trim();\n\t\t\tconst keyword = upperFirst(camelCase(rawKeyword));\n\t\t\tconst clause = expressions[i++].trim();\n\t\t\tconst handler = `_handle${keyword}`;\n\t\t\tthis[handler](clause);\n\t\t}\n\t\tthis._injectSubqueries(subqueries);\n\t\treturn true;\n\t}\n\n\t_handleSelect(clause) {\n\t\tlet columns = clause.split(/s*,s*/);\n\t\t// now handle parenthesis expressions that contain commas\n\t\tlet buffer = '';\n\t\tcolumns.forEach((column, i) => {\n\t\t\tif (i === 0) {\n\t\t\t\tconst optionRegex = /^(SQL_CALC_FOUND_ROWS)\\s+/i;\n\t\t\t\tconst match = column.match(optionRegex);\n\t\t\t\tif (match) {\n\t\t\t\t\tthis.query.option(match[1]);\n\t\t\t\t\tcolumn = column.replace(optionRegex, '');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (buffer.length) {\n\t\t\t\t// we are in the middle of an expression containing parenthesis\n\t\t\t\tbuffer += column + ',';\n\t\t\t\tif (column.indexOf(')') > 0) {\n\t\t\t\t\t// we have an end parenthesis\n\t\t\t\t\tbuffer = '';\n\t\t\t\t}\n\t\t\t} else if (column.match(/\\([^)]+$/)) {\n\t\t\t\tbuffer = column + ',';\n\t\t\t} else {\n\t\t\t\tthis.query.column(column.trim());\n\t\t\t}\n\t\t});\n\t}\n\n\t_handleFrom(clause) {\n\t\tconst tables = clause.split(/\\s*,\\s*/);\n\t\ttables.forEach(table => this.query.table(table));\n\t}\n\n\t_handleJoin(clause) {\n\t\tthis.query.innerJoin(clause);\n\t}\n\n\t_handleInnerJoin(clause) {\n\t\tthis.query.innerJoin(clause);\n\t}\n\n\t_handleLeftJoin(clause) {\n\t\tthis.query.leftJoin(clause);\n\t}\n\n\t_handleLeftOuterJoin(clause) {\n\t\tthis.query.leftOuterJoin(clause);\n\t}\n\n\t_handleRightJoin(clause) {\n\t\tthis.query.rightJoin(clause);\n\t}\n\n\t_handleRightOuterJoin(clause) {\n\t\tthis.query.rightOuterJoin(clause);\n\t}\n\n\t_handleCrossJoin(clause) {\n\t\tthis.query.crossJoin(clause);\n\t}\n\n\t_handleFullJoin(clause) {\n\t\tthis.query.fullJoin(clause);\n\t}\n\n\t_handleFullOuterJoin(clause) {\n\t\tthis.query.fullOuterJoin(clause);\n\t}\n\n\t_handleWhere(clause) {\n\t\tif (/^(1|'1'|true)$/i.test(clause)) {\n\t\t\tthis.query._wheres.push(clause);\n\t\t} else {\n\t\t\tthis._handleConditions('where', clause);\n\t\t}\n\t}\n\n\t_handleHaving(clause) {\n\t\tthis._handleConditions('having', clause);\n\t}\n\n\t/**\n\t * Build a conditions list\n\t * @param {String} type  Either WHERE or HAVING\n\t * @param {String} clause  The expressions following the type keyword\n\t */\n\t_handleConditions(type, clause) {\n\t\tconst andGroups = clause.split(/\\bAND\\b/i);\n\t\tandGroups.forEach(andGroup => {\n\t\t\tconst orPieces = andGroup.split(/\\bOR\\b/i).map(trim);\n\t\t\tif (orPieces.length === 1) {\n\t\t\t\t// no OR operators\n\t\t\t\tconst fn = type; // either where or having\n\t\t\t\tthis.query[fn](orPieces[0]);\n\t\t\t} else {\n\t\t\t\t// some OR operators\n\t\t\t\tconst orFn = 'or' + capitalize(type); // either orWhere or orHaving\n\t\t\t\tthis.query[orFn](orPieces);\n\t\t\t}\n\t\t});\n\t}\n\n\t_handleGroupBy(clause) {\n\t\tconst columns = clause.split(/\\s*,\\s*/);\n\t\tcolumns.forEach(column => this.query.groupBy(column));\n\t}\n\n\t_handleOrderBy(clause) {\n\t\tconst columns = clause.split(/\\s*,\\s*/);\n\t\tcolumns.forEach(column => this.query.orderBy(column));\n\t}\n\n\t_handleLimit(clause) {\n\t\tthis.limit(clause);\n\t}\n\n\t_handleOffset(clause) {\n\t\tthis.offset(clause);\n\t}\n}\n","import { Parser } from '../Parser/Parser.js';\nimport { Db } from '../Db/Db.js';\nimport cloneDeep from 'lodash.clonedeep';\nimport escapeRegExp from 'lodash.escaperegexp';\nimport forOwn from 'lodash.forown';\nimport uniq from 'lodash.uniq';\nimport substrCount from 'quickly-count-substrings';\nimport mysql from 'mysql2';\n\n/**\n * Build a select query\n * Class Select\n */\nexport class Select {\n\tparse(sql) {\n\t\tthis.reset();\n\t\tconst parser = new Parser(this);\n\t\tparser.parse(sql);\n\t\treturn this;\n\t}\n\n\tstatic parse(sql) {\n\t\tconst db = Db.factory();\n\t\treturn Select.init(db).parse(sql);\n\t}\n\n\t/**\n\t * Select constructor\n\t */\n\tconstructor(Db) {\n\t\tthis.db = Db;\n\t\tthis.reset();\n\t}\n\n\t/**\n\t * Shortcut to initialize without the `new` keyword\n\t * @return {Select}\n\t */\n\tstatic init(Db) {\n\t\treturn new Select(Db);\n\t}\n\n\t/**\n\t * Get the SQL as a pretty-printed string\n\t * @return {String}\n\t */\n\ttoString() {\n\t\tconst lines = [\n\t\t\t'SELECT',\n\t\t\tthis._options.length ? `  ${this._options.join('\\n  ')}` : null,\n\t\t\tthis._columns.length ? `  ${this._columns.join(',\\n  ')}` : '  *\\n',\n\t\t\t`FROM ${this._tables.join(', ')}`,\n\t\t\tthis._joins.length ? this._joins.join('\\n') : null,\n\t\t\tthis._wheres.length ? `WHERE ${this._wheres.join('\\n  AND ')}` : null,\n\t\t\tthis._groupBys.length ? `GROUP BY ${this._groupBys.join(',\\n  ')}` : null,\n\t\t\tthis._havings.length ? `HAVING ${this._havings.join('\\n  AND ')}` : null,\n\t\t\tthis._orderBys.length ? `ORDER BY ${this._orderBys.join(',\\n  ')}` : null,\n\t\t];\n\t\tif (this._page > 0) {\n\t\t\tconst offset = (this._page - 1) * this._limit;\n\t\t\tlines.push(`LIMIT ${this._limit}`);\n\t\t\tlines.push(`OFFSET ${offset}`);\n\t\t} else {\n\t\t\tif (this._limit > 0) {\n\t\t\t\tlines.push(`LIMIT ${this._limit}`);\n\t\t\t}\n\t\t\tif (this._offset > 0) {\n\t\t\t\tlines.push(`OFFSET ${this._offset}`);\n\t\t\t}\n\t\t}\n\n\t\treturn lines\n\t\t\t.filter(Boolean)\n\t\t\t.join('\\n')\n\t\t\t.trim();\n\t}\n\n\t/**\n\t * Get the SQL as a one-line string\n\t * @return {String}\n\t */\n\tnormalized() {\n\t\tconst lines = [\n\t\t\t'SELECT',\n\t\t\tthis._options.length ? this._options.join(' ') : null,\n\t\t\tthis._columns.length ? this._columns.join(', ') : '*',\n\t\t\t`FROM ${this._tables.join(', ')}`,\n\t\t\tthis._joins.length ? this._joins.join(' ') : null,\n\t\t\tthis._wheres.length ? `WHERE ${this._wheres.join(' AND ')}` : null,\n\t\t\tthis._groupBys.length ? `GROUP BY ${this._groupBys.join(', ')}` : null,\n\t\t\tthis._havings.length ? `HAVING ${this._havings.join(' AND ')}` : null,\n\t\t\tthis._orderBys.length ? `ORDER BY ${this._orderBys.join(', ')}` : null,\n\t\t];\n\n\t\tif (this._page > 0) {\n\t\t\tconst offset = (this._page - 1) * this._limit;\n\t\t\tlines.push(`LIMIT ${this._limit}`);\n\t\t\tlines.push(`OFFSET ${offset}`);\n\t\t} else {\n\t\t\tif (this._limit > 0) {\n\t\t\t\tlines.push(`LIMIT ${this._limit}`);\n\t\t\t}\n\t\t\tif (this._offset > 0) {\n\t\t\t\tlines.push(`OFFSET ${this._offset}`);\n\t\t\t}\n\t\t}\n\n\t\treturn lines\n\t\t\t.filter(Boolean)\n\t\t\t.join(' ')\n\t\t\t.trim();\n\t}\n\n\t/**\n\t * @param {String|Array} [field]  If given, reset the given component(s), otherwise reset all query components\n\t *     Valid components: option, column, table, where, orWhere, having, groupBy, orderBy, limit, offset, page\n\t * @return {Select}\n\t */\n\treset(field = null) {\n\t\tif (Array.isArray(field)) {\n\t\t\tfield.forEach(name => this.reset(name));\n\t\t\treturn this;\n\t\t}\n\t\tif (field) {\n\t\t\tlet prop = '_' + field.replace(/s$/, '');\n\t\t\tif (\n\t\t\t\t[\n\t\t\t\t\t'option',\n\t\t\t\t\t'column',\n\t\t\t\t\t'table',\n\t\t\t\t\t'where',\n\t\t\t\t\t'having',\n\t\t\t\t\t'groupBy',\n\t\t\t\t\t'orderBy',\n\t\t\t\t].indexOf(field) > -1\n\t\t\t) {\n\t\t\t\tprop += 's';\n\t\t\t}\n\t\t\tthis[prop] = ['limit', 'offset', 'page'].indexOf(field) > -1 ? null : [];\n\t\t} else {\n\t\t\tthis._hasOne = [];\n\t\t\tthis._belongsTo = [];\n\t\t\tthis._hasMany = [];\n\t\t\tthis._habtm = [];\n\t\t\tthis._options = [];\n\t\t\tthis._columns = [];\n\t\t\tthis._tables = [];\n\t\t\tthis._joins = [];\n\t\t\tthis._wheres = [];\n\t\t\tthis._havings = [];\n\t\t\tthis._groupBys = [];\n\t\t\tthis._orderBys = [];\n\t\t\tthis._limit = null;\n\t\t\tthis._offset = null;\n\t\t\tthis._page = null;\n\t\t\tthis._bound = [];\n\t\t}\n\t\treturn this;\n\t}\n\n\t// \t\t/**\n\t// \t\t * Internal function for defining a relationship for fetching dependent or related tate\n\t// \t\t * @param {String} type  One of hasOne, hasMany, habtm\n\t// \t\t * @param array $spec  The specification for the relationship\n\t// \t\t * @return {Select}\n\t// \t\t */\n\t// \t\trelate($type, $spec) {\n\t// \t\t\tif ($type == 'habtm' || $type == 'hasAndBelongsToMany') {\n\t// \t\t\t\tthis.relationships[] = [\n\t// \t\t\t\t\t'key' => $spec['thisProperty'],\n\t// \t\t\t\t\t'type' => 'habtm',\n\t// \t\t\t\t\t'thisProperty' => @$spec['key'] ?: $spec['thisProperty'],\n\t// \t\t\t\t\t'options' => $spec\n\t// \t\t\t];\n\t// \t\t\t}\n\t// \t\t\telseif ($type == 'hasOne') {\n\t// \t\t\t\t$spec['key'] = @$spec['key'] ?: preg_replace('/^\\S+ as (\\S+)$/i', '$1', $spec['thisProperty']);\n\t// \t\t\t\t$spec['type'] = 'hasOne';\n\t// \t\t\t\tthis.relationships[] = $spec;\n\t// \t\t\t}\n\t// \t\telse {\n\t// \t\t\t\t$spec['key'] = @$spec['key'] ?: $spec['thisProperty'];\n\t// \t\t\t\t$spec['type'] = $type;\n\t// \t\t\t\tthis.relationships[] = $spec;\n\t// \t\t\t}\n\t// \t\t\treturn this;\n\t// \t\t}\n\t//\n\t// \t\t/**\n\t// \t\t * Specify to fetch dependent data of the given type\n\t// \t\t * @param {String} key  The name of the relationship as previously defined\n\t// \t\t * @return {Select}\n\t// \t\t */\n\t// \t\tcontain($key) {\n\t// \t\t\tif ($key == 'ALL') {\n\t// \t\t\t\tforeach (this.relationships as $rel) {\n\t// \t\t\t\t\tthis.{'_' . $rel['type']}[] = $rel;\n\t// \t\t\t\t}\n\t// \t\t\t\treturn this;\n\t// \t\t\t}\n\t// \t\t\tforeach (this.relationships as $rel) {\n\t// \t\t\t\tif ($key == $rel['key']) {\n\t// \t\t\t\t\tthis.{'_' . $rel['type']}[] = $rel;\n\t// \t\t\t\t\treturn this;\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// //\t\tQuickLogger::write('hasOne', pprt($key, this.relationships));\n\t// \t\t\ttrigger_error(\"Unknown contain key `$key`\", E_USER_WARNING);\n\t// \t\t\treturn this;\n\t// \t\t}\n\t//\n\thasOne(thisProperty, thatTableAndColumn) {\n\t\tthis._hasOne.push({ thisProperty, thatTableAndColumn });\n\t\treturn this;\n\t}\n\n\tbelongsTo(thisProperty, thatTableAndColumn) {\n\t\tthis._belongsTo.push({ thisProperty, thatTableAndColumn });\n\t\treturn this;\n\t}\n\n\thasMany(thisProperty, thatTableAndColumn) {\n\t\tthis._hasMany.push({ thisProperty, thatTableAndColumn });\n\t\treturn this;\n\t}\n\n\thabtm(thisProperty, idsColumn, join) {\n\t\tconst matchJoinFirst = join.match(\n\t\t\t/(?:LEFT JOIN\\s*)?(.+)\\s+ON\\s+\\1\\.id\\s*=\\s*(.+)\\.(.+)/\n\t\t);\n\t\tconst matchJoinSecond = join.match(\n\t\t\t/(?:LEFT JOIN\\s*)?(.+)\\s+ON\\s+(.+)\\.(.+)\\s*=\\s*\\1\\.id/\n\t\t);\n\t\tif (!matchJoinFirst && !matchJoinSecond) {\n\t\t\tthrow new Error(\n\t\t\t\t`Select: Unknown join pattern: \"${join}\". Expecting format \"joinTable ON joinTable.id = throughTable.foreignColumn\"`\n\t\t\t);\n\t\t}\n\t\tlet [_, joinTable, throughTable, foreignColumn] =\n\t\t\tmatchJoinFirst || matchJoinSecond;\n\t\tthis._habtm.push({\n\t\t\tthisProperty,\n\t\t\tidsColumn,\n\t\t\tjoin,\n\t\t\tjoinTable,\n\t\t\tthroughTable,\n\t\t\tforeignColumn,\n\t\t});\n\t\treturn this;\n\t}\n\n\thasAndBelongsToMany(thisProperty, idsColumn, join) {\n\t\treturn this.habtm(thisProperty, idsColumn, join);\n\t}\n\n\t/**\n\t * Bind values by name to the query\n\t * @param {Object|String} placeholder  The name of the placeholder or an object with placeholder: value pairs\n\t * @param {*} [value=null]  The value to bind when placeholder is a string\n\t * @example\n\t *     query.bind('postId', 123); // replace :postId with '123'\n\t * @return {Select}\n\t */\n\tbind(placeholder, value = null) {\n\t\tif (typeof placeholder === 'object' && value === null) {\n\t\t\tforOwn(placeholder, (val, field) => {\n\t\t\t\tthis._bound[field] = val;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t\tthis._bound[placeholder] = value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unbind a previously bound property\n\t * @param {String} placeholder\n\t * @return {Select}\n\t */\n\tunbind(placeholder) {\n\t\tif (Array.isArray(placeholder)) {\n\t\t\tplaceholder.forEach(p => this.unbind(p));\n\t\t\treturn this;\n\t\t}\n\t\tthis._bound[placeholder] = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Fetch records and splice in related data\n\t * @return {Promise<Array>}\n\t */\n\tasync fetch(options = {}) {\n\t\toptions.sql = this.toString();\n\t\tconst records = await this.db.select(options, this._bound);\n\t\tawait this._spliceHasOnes(records);\n\t\tawait this._spliceBelongsTos(records);\n\t\tawait this._spliceHasManys(records);\n\t\tawait this._spliceHabtms(records);\n\t\treturn records;\n\t}\n\n\t/**\n\t * Fetch the first matched record\n\t * @return {Object|null}\n\t */\n\tasync fetchFirst() {\n\t\tthis.limit(1);\n\t\tconst records = await this.fetch();\n\t\treturn Array.isArray(records) && records.length ? records[0] : null;\n\t}\n\n\t/**\n\t * Fetch each record as an array of values or an array of key-value pairs\n\t * @return {Promise<Object>}\n\t */\n\tfetchHash() {\n\t\treturn this.db.selectHash(this.toString(), this._bound);\n\t}\n\n\t/**\n\t * Fetch the value of first column of the first record\n\t * @return {Promise}\n\t */\n\tfetchValue() {\n\t\treturn this.db.selectValue(this.toString(), this._bound);\n\t}\n\n\t/**\n\t * Fetch values and index by the given field name\n\t * @param {String} byField  The field by which to index (e.g. id)\n\t * @return {Promise<Object>}\n\t */\n\tasync fetchIndexed(byField) {\n\t\tconst rs = await this.fetch();\n\t\tif (!Array.isArray(rs)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst indexed = {};\n\t\trs.forEach(r => (indexed[r[byField]] = r));\n\t\treturn indexed;\n\t}\n\n\t/**\n\t * Fetch values grouped by the given field name\n\t * @param {String} byField  The field by which to group\n\t * @example\n\t *      const query = Select.parse('SELECT * FROM comments');\n\t *      const byUser = query.fetchGrouped('user_id')\n\t *      // a key for each user id with an array of comments for each key\n\t * @return {Array}\n\t */\n\tasync fetchGrouped(byField) {\n\t\tconst rs = await this.fetch();\n\t\tif (!Array.isArray(rs)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst grouped = {};\n\t\trs.forEach(r => {\n\t\t\tif (!grouped[r[byField]]) {\n\t\t\t\tgrouped[r[byField]] = [];\n\t\t\t}\n\t\t\tgrouped[r[byField]].push(r);\n\t\t});\n\t\treturn grouped;\n\t}\n\n\t/**\n\t * Clone this object\n\t * @return {Select}\n\t */\n\tgetClone() {\n\t\tconst copy = new Select();\n\t\tcopy._hasOne = cloneDeep(this._hasOne);\n\t\tcopy._belongsTo = cloneDeep(this._belongsTo);\n\t\tcopy._hasMany = cloneDeep(this._hasMany);\n\t\tcopy._habtm = cloneDeep(this._habtm);\n\t\tcopy._options = cloneDeep(this._options);\n\t\tcopy._columns = cloneDeep(this._columns);\n\t\tcopy._tables = cloneDeep(this._tables);\n\t\tcopy._joins = cloneDeep(this._joins);\n\t\tcopy._wheres = cloneDeep(this._wheres);\n\t\tcopy._havings = cloneDeep(this._havings);\n\t\tcopy._groupBys = cloneDeep(this._groupBys);\n\t\tcopy._orderBys = cloneDeep(this._orderBys);\n\t\tcopy._limit = this._limit;\n\t\tcopy._offset = this._offset;\n\t\tcopy._page = this._page;\n\t\tcopy._bound = cloneDeep(this._bound);\n\t\treturn copy;\n\t}\n\n\t/**\n\t * Build a version of this query that simply returns COUNT(*)\n\t * @param {String} [countExpr=\"*\"]  Use to specify `DISTINCT colname` if needed\n\t * @return {Select}  The SQL query\n\t */\n\tgetFoundRowsQuery(countExpr = '*') {\n\t\tif (this._havings.length === 0) {\n\t\t\tconst clone = this.getClone();\n\t\t\tclone._columns = [`COUNT(${countExpr}) AS foundRows`];\n\t\t\tclone._options = [];\n\t\t\tclone._groupBys = [];\n\t\t\tclone._orderBys = [];\n\t\t\tclone._limit = null;\n\t\t\tclone._offset = null;\n\t\t\tclone._page = null;\n\t\t\treturn clone;\n\t\t} else {\n\t\t\tconst subquery = this.getClone();\n\t\t\tsubquery._limit = null;\n\t\t\tsubquery._offset = null;\n\t\t\tsubquery._page = null;\n\t\t\treturn subquery;\n\t\t}\n\t}\n\n\tgetFoundRowsSql(countExpr, normalize = false) {\n\t\tconst query = this.getFoundRowsQuery(countExpr);\n\t\tif (this._havings.length === 0) {\n\t\t\treturn normalize ? query.normalized() : query.toString();\n\t\t} else if (normalize) {\n\t\t\tconst subquerySql = query.normalized();\n\t\t\treturn `SELECT COUNT(*) AS foundRows FROM (${subquerySql}) AS subq`;\n\t\t} else {\n\t\t\tconst subquerySql = query.toString().replace(/\\n/g, '\\n\\t');\n\t\t\treturn `SELECT COUNT(*) AS foundRows FROM (\\n\\t${subquerySql}\\n) AS subq`;\n\t\t}\n\t}\n\n\t/**\n\t * Run a version of this query that simply returns COUNT(*)\n\t * @param {String} [countExpr=\"*\"]  Use to specify `DISTINCT colname` if needed\n\t * @return {Promise<Number>}  The number of rows or false on error\n\t */\n\tfoundRows(countExpr = '*') {\n\t\tconst sql = this.getFoundRowsSql(countExpr);\n\t\treturn this.db.selectValue(sql, this._bound);\n\t}\n\n\t/**\n\t * Internal method to fetch hasOne dependent data and splice it into the given result set\n\t * @param {Array} records  Records from .fetch()\n\t */\n\tasync _spliceHasOnes(records) {\n\t\tif (this._hasOne.length === 0 || records.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis._hasOne.forEach(async spec => {\n\t\t\tconst match = spec.thisProperty.match(/^([\\w_]+) AS ([\\w_]+)$/i);\n\t\t\tlet thisProperty;\n\t\t\tif (match) {\n\t\t\t\tthisProperty = match[2];\n\t\t\t\tspec.thisColumn = match[1];\n\t\t\t} else {\n\t\t\t\tthisProperty = spec.thisProperty.replace(/_id$/, '');\n\t\t\t}\n\t\t\tconst [table, column] = spec.thatTableAndColumn.split('.');\n\t\t\tlet ids = [];\n\t\t\trecords.forEach(r => {\n\t\t\t\tif (r[spec.thisColumn]) {\n\t\t\t\t\tids.push(r[spec.thisColumn]);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (ids.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tids = uniq(ids);\n\t\t\tconst query = Select.init()\n\t\t\t\t.table(table)\n\t\t\t\t.where(column, 'IN', ids);\n\t\t\tconst indexed = await query.fetchIndexed(column);\n\t\t\trecords.forEach(r => {\n\t\t\t\tr[thisProperty] = indexed[r[spec.thisColumn]] || null;\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Internal method to fetch belongTo dependent data and splice it into the given result set\n\t * @param {Array} records  The records from fetch()\n\t */\n\tasync _spliceBelongsTos(records) {\n\t\tif (this._belongsTo.length === 0 || records.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst ids = uniq(records.map(r => r.id));\n\t\tthis._belongsTo.forEach(async spec => {\n\t\t\tconst [table, column] = spec.thatTableAndColumn.split('.');\n\t\t\tconst indexed = await Select.init(this.db)\n\t\t\t\t.table(table)\n\t\t\t\t.where(column, 'IN', ids)\n\t\t\t\t.fetchIndexed(column);\n\t\t\trecords.forEach(r => {\n\t\t\t\tr[spec.thisPropery] = indexed[r.id] || null;\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Internal method to fetch hasMany dependent data and splice it into the given result set\n\t * @param {Array} records  The records from fetch()\n\t */\n\tasync _spliceHasManys(records) {\n\t\tif (this._hasMany.length === 0 || records.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst ids = uniq(records.map(r => r.id));\n\t\tthis._hasMany.forEach(async spec => {\n\t\t\tconst [table, column] = spec.thatTableAndColumn.split('.');\n\t\t\tconst query = Select.init()\n\t\t\t\t.table(table)\n\t\t\t\t.where(column, 'IN', ids);\n\t\t\tconst grouped = await query.fetchGrouped(column);\n\t\t\trecords.forEach(r => {\n\t\t\t\tr[spec.thisPropery] = grouped[r.id] || [];\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Internal method to fetch habtm dependent data and splice it into the given result set\n\t * @param {Array} records  The records from fetch()\n\t * @example\n\t * const query = Select.parse('SELECT * FROM users');\n\t * query.habtm(\n\t *   'hubs',\n\t *   'SELECT user_id, client_id FROM clients_users WHERE user_id IN (?)',\n\t *   'SELECT * FROM clients WHERE id IN(?)'\n\t * );\n\t */\n\tasync _spliceHabtms(records) {\n\t\tif (this._habtm.length === 0 || records.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst ids = uniq(records.map(r => r.id));\n\t\tthis._habtm.forEach(async spec => {\n\t\t\t// const { joinTableQuery, foreignTable } = spec;\n\t\t\t// const joinTableLookup = await this.db.selectGrouped('user_id', joinTableQuery, ids);\n\t\t\t// const foreignIds = uniq(values(joinTableLookup));\n\t\t\t// const foreignQuery = Select.init()\n\t\t\t// \t.table(foreignTable)\n\t\t\t// \t.where('id', 'IN', foreignIds);\n\t\t\t// const foreignRecords = await foreignQuery.fetchIndexed('id');\n\t\t\t// const { thisProperty, idsColumn, join, throughTable, subqueryHandler } = spec;\n\t\t\t// const subquery = Select.init()\n\t\t\t// \t.table(throughTable)\n\t\t\t// \t.leftJoin(join)\n\t\t\t// \t.where(`${throughTable}.${idsColumn}`, 'IN', ids);\n\t\t\t// if (subqueryHandler) {\n\t\t\t// \tsubqueryHandler(subquery);\n\t\t\t// }\n\t\t\t// const grouped = await subquery.fetchIndexed(idsColumn);\n\t\t\t// records.forEach(r => {\n\t\t\t// \tr[thisProperty] = grouped[r.id] || [];\n\t\t\t// });\n\t\t});\n\t}\n\n\t/**\n\t * Add an array of column names to fetch\n\t * @param {String[]} columnNames  The names of columns\n\t * @return {Select}\n\t */\n\tcolumns(columnNames) {\n\t\tthis._columns = [...this._columns, ...columnNames];\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a column name to fetch\n\t * @param {String} columnName  The name of the column\n\t * @return {Select}\n\t */\n\tcolumn(columnName) {\n\t\tthis._columns.push(columnName);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an option expression such as \"TOP 10\" or \"SQL_CALC_FOUND_ROWS\"\n\t * @param {String} optionExpression  Expression to go after \"SELECT\" and before column list\n\t * @return {Select}\n\t */\n\toption(optionExpression) {\n\t\tthis._options.push(optionExpression);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a table to the \"FROM\" clause (same as .from())\n\t * @param {String} tableName  The name of the table to query\n\t * @return {Select}\n\t */\n\ttable(tableName) {\n\t\tthis._tables.push(tableName);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a table to the \"FROM\" clause (same as .table())\n\t * @param {String} tableName  The name of the table to query\n\t * @return {Select}\n\t */\n\tfrom(tableName) {\n\t\tthis._tables.push(tableName);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an INNER JOIN expression (same as ->innerJoin())\n\t * @param {String} expression  The expression following the INNER JOIN keyword\n\t * @example query.join('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\tjoin(expression) {\n\t\tthis._joins.push(`INNER JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a LEFT JOIN expression\n\t * @param {String} expression  The expression following the LEFT JOIN keyword\n\t * @example query.leftJoin('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\tleftJoin(expression) {\n\t\tthis._joins.push(`LEFT JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a FULL JOIN expression\n\t * @param {String} expression  The expression following the FULL JOIN keyword\n\t * @example query.fullJoin('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\tfullJoin(expression) {\n\t\tthis._joins.push(`FULL JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a RIGHT JOIN expression\n\t * @param {String} expression  The expression following the RIGHT JOIN keyword\n\t * @example query.rightJoin('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\trightJoin(expression) {\n\t\tthis._joins.push(`RIGHT JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a CROSS JOIN expression\n\t * @param {String} expression  The expression following the CROSS JOIN keyword\n\t * @example query.join('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\tcrossJoin(expression) {\n\t\tthis._joins.push(`CROSS JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an INNER JOIN expression (same as ->join())\n\t * @param {String} expression  The expression following the INNER JOIN keyword\n\t * @example query.innerJoin('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\tinnerJoin(expression) {\n\t\tthis._joins.push(`INNER JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a LEFT OUTER JOIN expression\n\t * @param {String} expression  The expression following the LEFT OUTER JOIN keyword\n\t * @example query.leftOuterJoin('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\tleftOuterJoin(expression) {\n\t\tthis._joins.push(`LEFT OUTER JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a FULL OUTER JOIN expression\n\t * @param {String} expression  The expression following the FULL OUTER JOIN keyword\n\t * @example query.fullOuterJoin('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\tfullOuterJoin(expression) {\n\t\tthis._joins.push(`FULL OUTER JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a RIGHT OUTER JOIN expression\n\t * @param {String} expression  The expression following the RIGHT OUTER JOIN keyword\n\t * @example query.rightOuterJoin('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\trightOuterJoin(expression) {\n\t\tthis._joins.push(`RIGHT OUTER JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove a join condition with the specified table\n\t * @param {String|String[]} table  The name of the table or tables in the first part of the join statement\n\t * @return {Select}\n\t */\n\tunjoin(table) {\n\t\tif (Array.isArray(table)) {\n\t\t\ttable.forEach(t => this.unjoin(t));\n\t\t\treturn this;\n\t\t}\n\t\ttable = escapeRegExp(table);\n\t\tthis._joins = this._joins.filter(join => {\n\t\t\tconst regex = new RegExp(`^([A-Z]+) JOIN ${table}\\\\b`);\n\t\t\treturn !regex.test(join);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Utility function to add conditions for a clause (WHERE, HAVING)\n\t * @param {String} collection  The collection to add the clauses to\n\t * @param {Array} criteria  A list of expressions to stringify\n\t * @property {*} criteria[0]  The expression or name of the column on which to match\n\t * @property {*} [criteria[1]]  The comparison operator; defaults to \"=\"\n\t * @property {*} [criteria[2]]  The value to test against\n\t * @example  The following are equivalent\n\t *     this._conditions(this._wheres, ['deleted_at IS NULL']);\n\t *     this._conditions(this._wheres, ['deleted_at', null]);\n\t *     this._conditions(this._wheres, ['deleted_at', '=', null]);\n\t * @example  More examples\n\t *     this._conditions(this._wheres, ['fname', 'LIKE', 'joe']); // fname LIKE 'joe'\n\t *     this._conditions(this._wheres, ['fname', 'LIKE ?', 'joe']); // fname LIKE 'joe'\n\t *     this._conditions(this._wheres, ['fname LIKE %?%', 'joe']); // fname LIKE '%joe%'\n\t *     this._conditions(this._wheres, ['fname LIKE ?%', 'joe']); // fname LIKE 'joe%'\n\t *     this._conditions(this._wheres, ['fname', 'LIKE ?%', 'joe']); // fname LIKE 'joe%'\n\t *     this._conditions(this._wheres, ['price >', 10]); // price > '10'\n\t *     this._conditions(this._wheres, ['price', '>', 10]); // price > '10'\n\t *     this._conditions(this._wheres, ['price =', 10]); // price = '10'\n\t *     this._conditions(this._wheres, ['price !=', 10]); // price != '10'\n\t *     this._conditions(this._wheres, ['price', 10]); // price = '10'\n\t *     this._conditions(this._wheres, ['price', '=', 10]); // price = '10'\n\t *     this._conditions(this._wheres, ['price', '!=', 10]); // price != '10'\n\t *     this._conditions(this._wheres, ['price', 'BETWEEN', [10,20]]); // price BETWEEN '10' AND '20'\n\t *     this._conditions(this._wheres, ['price', 'NOT BETWEEN', [10,20]]); // price NOT BETWEEN '10' AND '20'\n\t *     this._conditions(this._wheres, ['price', [10,20]]); // price IN('10','20')\n\t *     this._conditions(this._wheres, ['price', '=', [10,20]]); // price IN('10','20')\n\t *     this._conditions(this._wheres, ['price', 'IN', [10,20]]); // price IN('10','20')\n\t *     this._conditions(this._wheres, ['price', 'NOT IN', [10,20]]); // price NOT IN('10','20')\n\t * @return {Select}\n\t */\n\t_conditions(collection, criteria) {\n\t\tif (typeof criteria === 'string') {\n\t\t\tcollection.push(criteria);\n\t\t\treturn this;\n\t\t}\n\t\tconst numArgs = criteria.length;\n\t\tlet [column, operator, value] = criteria;\n\t\tif (Array.isArray(column)) {\n\t\t\tcolumn.forEach(val => {\n\t\t\t\tthis._conditions(collection, [val]);\n\t\t\t});\n\t\t\treturn this;\n\t\t} else if (typeof column === 'object') {\n\t\t\tforOwn(column, (val, name) => {\n\t\t\t\tthis._conditions(collection, [name, val]);\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t\tif (/^\\w+$/.test(column)) {\n\t\t\tcolumn = mysql.escapeId(column);\n\t\t}\n\t\tif (numArgs === 1) {\n\t\t\t// condition is a stand-alone expression\n\t\t\t// e.g. \"SUM(price) > 10\"\n\t\t\tcollection.push(column);\n\t\t\treturn this;\n\t\t} else if (\n\t\t\tnumArgs === 2 &&\n\t\t\tArray.isArray(operator) &&\n\t\t\toperator.length > 0 &&\n\t\t\tsubstrCount(column, '?') === operator.length\n\t\t) {\n\t\t\tconst values = operator;\n\t\t\tlet i = 0;\n\t\t\tconst sql = column.replace(/(%)?\\?(%)?/, ($0, $1, $2) => {\n\t\t\t\tconst escNoQuotes = this.escapeQuoteless(values[i++]);\n\t\t\t\treturn `'${$1}${escNoQuotes}${$2}'`;\n\t\t\t});\n\t\t\tcollection.push(sql);\n\t\t\treturn this;\n\t\t} else if (numArgs === 2) {\n\t\t\t// condition has pairs of \"column + operator\" => \"value\"\n\t\t\t// e.g. [\"price >\", 10]\n\t\t\t// e.g. [\"status LIKE ?%\", 10]\n\t\t\tvalue = operator;\n\t\t\tconst parts = column.split(' ');\n\t\t\tcolumn = parts.shift();\n\t\t\toperator = parts.join(' ');\n\t\t}\n\t\tif (!operator) {\n\t\t\toperator = '=';\n\t\t}\n\t\toperator = operator.toLocaleUpperCase();\n\t\tconst likeMatch = operator.match(\n\t\t\t/^(LIKE|NOT LIKE)(?: (\\?|\\?%|%\\?|%\\?%))?$/\n\t\t);\n\t\tif (operator === 'NOT BETWEEN' || operator === 'BETWEEN') {\n\t\t\t// expect a two-item array\n\t\t\tconst from = mysql.escape(value[0]);\n\t\t\tconst to = mysql.escape(value[1]);\n\t\t\tcollection.push(`${column} ${operator} ${from} AND ${to}`);\n\t\t} else if (likeMatch) {\n\t\t\tconst quoteless = this.escapeQuoteless(value);\n\t\t\tlet quoted;\n\t\t\tif (likeMatch[2] === '?' || !likeMatch[2]) {\n\t\t\t\tquoted = `'${quoteless}'`;\n\t\t\t} else if (likeMatch[2] === '?%') {\n\t\t\t\tquoted = `'${quoteless}%'`;\n\t\t\t} else if (likeMatch[2] === '%?') {\n\t\t\t\tquoted = `'%${quoteless}'`;\n\t\t\t} else if (likeMatch[2] === '%?%') {\n\t\t\t\tquoted = `'%${quoteless}%'`;\n\t\t\t}\n\t\t\tcollection.push(`${column} ${likeMatch[1]} ${quoted}`);\n\t\t} else if (value === null) {\n\t\t\tcollection.push(\n\t\t\t\toperator === '=' ? `${column} IS NULL` : `${column} IS NOT NULL`\n\t\t\t);\n\t\t} else if (Array.isArray(value)) {\n\t\t\t// an array of values should be IN or NOT IN\n\t\t\tconst inVals = value.map(v => mysql.escape(v));\n\t\t\tconst joined = inVals.join(',');\n\t\t\tcollection.push(\n\t\t\t\toperator === '=' || operator === 'IN'\n\t\t\t\t\t? `${column} IN(${joined})`\n\t\t\t\t\t: `${column} NOT IN(${joined})`\n\t\t\t);\n\t\t} else if (operator === 'IN' || operator === 'NOT IN') {\n\t\t\t// in clause that is not array\n\t\t\tvalue = mysql.escape(value);\n\t\t\tcollection.push(`${column} ${operator} (${value})`);\n\t\t} else {\n\t\t\tvalue = mysql.escape(value);\n\t\t\tcollection.push(`${column} ${operator} ${value}`);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a group by column or expression\n\t * @param {String} column  The name of a column (or expression) to group by\n\t * @return {Select}\n\t */\n\tgroupBy(column) {\n\t\tthis._groupBys.push(column);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add WHERE clauses to conditions (See _conditions for usage)\n\t * @param {String} column  The expression or name of the column on which to match\n\t * @param {*} [operator]  The comparison operator; defaults to \"=\"\n\t * @param {*} [value]  The value to test against\n\t * @return {Select}\n\t */\n\twhere(...args) {\n\t\tthis._conditions(this._wheres, args);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a WHERE clause with a BETWEEN condition\n\t * @param {String} column  The column name\n\t * @param {Array} twoValueArray  The two values to be between\n\t * @return {Select}\n\t */\n\twhereBetween(column, twoValueArray) {\n\t\tif (twoValueArray[0] && twoValueArray[1]) {\n\t\t\tthis.where(column, 'BETWEEN', twoValueArray);\n\t\t} else if (twoValueArray[0]) {\n\t\t\tthis.where(column, '>=', twoValueArray[0]);\n\t\t} else if (twoValueArray.length > 1) {\n\t\t\tthis.where(column, '<=', twoValueArray[1]);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add WHERE conditions to place inside an OR block (See _conditions for usage)\n\t * @param {Array} conditions  A list where each item is an array with parameters that would be taken by where()\n\t * @return {Select}\n\t */\n\torWhere(conditions) {\n\t\tconst criteria = [];\n\t\tconditions.forEach(condition => {\n\t\t\tthis._conditions(criteria, condition);\n\t\t});\n\t\tconst joined = criteria.join(' OR ');\n\t\tif (joined.slice(0, 1) === '(' && joined.slice(-1) === ')') {\n\t\t\tthis.where(joined);\n\t\t} else {\n\t\t\tthis.where(`(${joined})`);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a HAVING condition (See _conditions for usage)\n\t * @param {String} column  The expression or name of the column on which to match\n\t * @param {*} [operator]  The comparison operator; defaults to \"=\"\n\t * @param {*} [value]  The value to test against\n\t * @return {Select}\n\t */\n\thaving(...args) {\n\t\tthis._conditions(this._havings, args);\n\t\treturn this;\n\t}\n\torHaving(conditions) {\n\t\tconst criteria = [];\n\t\tconditions.forEach(condition => {\n\t\t\tthis._conditions(criteria, condition);\n\t\t});\n\t\tconst joined = criteria.join(' OR ');\n\t\tthis.having(`(${joined})`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a column or expression to order by\n\t * @param {String} column  The column name or expression to sort by. Include DESC or prefix with - to sort descending\n\t * @return {Select}\n\t */\n\torderBy(column) {\n\t\tthis._orderBys.push(column.replace(/^-(.+)/, '$1 DESC'));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sort by the given column, with a map of columns to translate\n\t * @param {String} column  The column name such as \"created_at\" or \"-created_at\" for descending\n\t * @param {Object} [mapNames={}]  Column names to translate from one name to another\n\t * @example\n\t *     query.sortField('-modified_at'); // ORDER BY modified_at DESC\n\t *     query.sortField('created_at', ['created_at'=>'created']); // ORDER BY created\n\t * @return {Select}\n\t */\n\tsortField(column, mapNames = {}) {\n\t\tconst direction = column.slice(0, 1) === '-' ? 'DESC' : 'ASC';\n\t\tcolumn = column.replace(/^-/, '');\n\t\tcolumn = mapNames[column] || column;\n\t\tthis.orderBy(`${column} ${direction}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Limit results to the given number\n\t * @param {Number} num  The number to limit by\n\t * @return {Select}\n\t */\n\tlimit(num) {\n\t\tthis._limit = Number(num) || 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Fetch results from the given offset\n\t * @param {Number} num  The offset\n\t * @return {Select}\n\t */\n\toffset(num) {\n\t\tthis._offset = Number(num) || 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the offset based on the limit with the given number of pages\n\t * @param {Number} num  The page number\n\t * @return {Select}\n\t */\n\tpage(num) {\n\t\tthis._page = Number(num) || 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Manually escape a value\n\t * @param {*} value  The value to escape\n\t * @return {string}\n\t */\n\tescape(value) {\n\t\treturn mysql.escape(value);\n\t}\n\n\t/**\n\t * Manually escape a value without quotes\n\t * @param {*} value  The value to escape without quotes\n\t * @return {string}\n\t */\n\tescapeQuoteless(value) {\n\t\tconst escaped = mysql.escape(value);\n\t\tif (escaped.slice(0, 1) === \"'\" && escaped.slice(-1) === \"'\") {\n\t\t\treturn escaped.slice(1, -1);\n\t\t}\n\t\treturn value;\n\t}\n}\n","import { Db } from './Db/Db.js';\nimport { Parser } from './Parser/Parser.js';\nimport { Select } from './Select/Select.js';\nexport { Db, Parser, Select };\n"]}