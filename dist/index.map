{"version":3,"sources":["Db/Db.js","Parser/Parser.js","Select/Select.js","entry.js"],"names":["Db","constructor","config","mocks","env","process","host","hostname","DB_HOSTNAME","user","username","DB_USERNAME","password","DB_PASSWORD","database","DB_DATABASE","port","DB_PORT","encoding","DB_ENCODING","factory","instance","connect","connection","mysql","createConnection","err","fatal","Error","code","sqlMessage","connectOnce","select","sql","bindVars","options","bindArgs","Promise","resolve","reject","lastQuery","query","error","results","fields","lastFields","selectHash","key","name","val","hash","forEach","result","selectList","list","push","selectGrouped","groupField","selectIndexed","indexField","selectFirst","selectValue","selectExists","then","Boolean","insert","insertId","update","changedRows","delete","selectFrom","table","params","extra","escFields","map","field","escapeId","length","join","buildWheres","trim","selectId","id","selectRecordByKey","selectUuid","uuid","column","value","escTable","escColumn","findIdOrCreate","newValues","insertInto","values","insertError","insertResults","updateTable","set","where","deleteFrom","limit","wheres","clauses","hasOwnProperty","buildWhere","operator","split","toUpperCase","escape","Array","isArray","args","arg","replace","$0","$1","escapeQuoteless","slice","tpl","supported","functions","templateData","variables","toSql","s","variable","i","mock","when","data","cb","RegExp","test","Parser","_stripComments","_extractSubqueries","subqueries","extractor","placeholder","_injectSubqueries","replacer","mapper","clause","_columns","_joins","_wheres","_havings","_split","parse","rawSql","stripped","expressions","rawKeyword","keyword","handler","_handleSelect","columns","buffer","optionRegex","match","option","indexOf","_handleFrom","_handleJoin","innerJoin","_handleInnerJoin","_handleLeftJoin","leftJoin","_handleLeftOuterJoin","leftOuterJoin","_handleRightJoin","rightJoin","_handleRightOuterJoin","rightOuterJoin","_handleCrossJoin","crossJoin","_handleFullJoin","fullJoin","_handleFullOuterJoin","fullOuterJoin","_handleWhere","_handleConditions","_handleHaving","type","andGroup","orPieces","fn","orFn","_handleGroupBy","groupBy","_handleOrderBy","orderBy","_handleLimit","_handleOffset","offset","Select","reset","db","init","toString","lines","_options","_tables","_groupBys","_orderBys","_page","_limit","_offset","filter","normalized","prop","_hasOne","_belongsTo","_hasMany","_habtm","_bound","hasOne","thisProperty","thatTableAndColumn","belongsTo","hasMany","habtm","idsColumn","matchJoinFirst","matchJoinSecond","_","joinTable","throughTable","foreignColumn","hasAndBelongsToMany","bind","unbind","p","undefined","fetch","records","_spliceHasOnes","_spliceBelongsTos","_spliceHasManys","_spliceHabtms","fetchFirst","fetchHash","fetchValue","fetchIndexed","byField","rs","indexed","r","fetchGrouped","grouped","getClone","copy","getFoundRowsQuery","countExpr","clone","subquery","getFoundRowsSql","normalize","foundRows","spec","thisColumn","ids","thisPropery","columnNames","columnName","optionExpression","tableName","from","expression","unjoin","t","_conditions","collection","criteria","numArgs","$2","parts","shift","likeMatch","toLocaleUpperCase","to","quoteless","quoted","inVals","joined","v","whereBetween","twoValueArray","orWhere","conditions","condition","having","orHaving","sortField","mapNames","direction","num","Number","page","escaped"],"mappings":"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","file":"index.map","sourceRoot":"../src","sourcesContent":["import mysql from 'mysql';\n\n/**\n * Simple database class for mysql\n */\nexport class Db {\n\t/**\n\t * Connection options including host, login, password, encoding, database\n\t * @param {Object} config  Configuration object\n\t */\n\tconstructor(config = {}) {\n\t\tthis.mocks = [];\n\t\tconst env = typeof process === 'object' && typeof process.env === 'object' ? process.env : {};\n\t\tthis.config = {\n\t\t\thost: config.hostname || env.DB_HOSTNAME || '127.0.0.1',\n\t\t\tuser: config.username || env.DB_USERNAME || 'root',\n\t\t\tpassword: config.password || env.DB_PASSWORD || '',\n\t\t\tdatabase: config.database || env.DB_DATABASE || 'platform',\n\t\t\tport: config.port || env.DB_PORT || 3306,\n\t\t\tencoding: config.encoding || env.DB_ENCODING || 'utf-8',\n\t\t};\n\t}\n\n\t/**\n\t * Create a new QuickDb instance or return the last used one\n\t * @param {Object} [config]  In the format required by mysql js\n\t * @return {Db}\n\t */\n\tstatic factory(config = {}) {\n\t\tif (!Db.instance) {\n\t\t\tDb.instance = new Db(config);\n\t\t}\n\t\treturn Db.instance;\n\t}\n\n\t/**\n\t * Make a new connection to MySQL\n\t */\n\tconnect() {\n\t\tthis.connection = mysql.createConnection(this.config);\n\t\tthis.connection.connect(err => {\n\t\t\tif (err && err.fatal) {\n\t\t\t\tthrow new Error(`[${err.code}] ${err.sqlMessage}`);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Make a new connection to MySQL if not already connected\n\t */\n\tconnectOnce() {\n\t\tif (!this.connection) {\n\t\t\tthis.connect();\n\t\t}\n\t}\n\n\t// /**\n\t//  * Run a list of semicolon-delimited queries\n\t//  * @see https://www.npmjs.com/package/mysql#multiple-statement-queries\n\t//  * @param {String} sql\n\t//  * @param int|string $bindVar1  The value to bind to the first question mark\n\t//  * @param int|string $bindVarN  The value to bind to the nth question mark\n\t//  * @return {Array}|bool\n\t//  */\n\t// multiQuery(/*$sql, $bindVar1, $bindVarN*/) {\n\t// \tif (!$this->_connectOnce()) {\n\t// \t\treturn false;\n\t// \t}\n\t// \t$sql = $this->bindArgs(func_get_args());\n\t// \t$ok = mysqli_multi_query($this->_dbh, $sql);\n\t// \tif (!$ok) {\n\t// \t\treturn false;\n\t// \t}\n\t// \t$fetch = \"mysqli_fetch_$this->fetchMode\";\n\t// \t$resultSets = [];\n\t// \twhile(1) {\n\t// \t\t/* get first result set */\n\t// \t\t$resultSet = [];\n\t// \t\tif (($result = mysqli_store_result($this->_dbh))) {\n\t// \t\t\twhile (($row = $fetch($result))) {\n\t// \t\t\t\t$resultSet[] = $row;\n\t// \t\t\t}\n\t// \t\t\tmysqli_free_result($result);\n\t// \t\t}\n\t// \t\t$resultSets[] = $resultSet;\n\t// \t\tif (!mysqli_next_result($this->_dbh)) {\n\t// \t\t\tbreak;\n\t// \t\t}\n\t// \t}\n\t// \treturn $resultSets;\n\t// }\n\n\t/**\n\t * Return result rows for the given SELECT statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Object[]>}\n\t */\n\tselect(sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(options, (error, results, fields) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tthis.lastFields = fields;\n\t\t\t\t\tresolve(results);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Return result array as col1 => col2 pairs for the given SELECT statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Object>}\n\t */\n\tselectHash(sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(options, bindVars, (error, results, fields) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tthis.lastFields = fields;\n\t\t\t\t\tconst key = fields[0].name;\n\t\t\t\t\tconst val = fields[1].name;\n\t\t\t\t\tconst hash = {};\n\t\t\t\t\tresults.forEach(result => {\n\t\t\t\t\t\thash[result[key]] = result[val];\n\t\t\t\t\t});\n\t\t\t\t\tresolve(hash);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Return result array as col1 => col2 pairs for the given SELECT statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Object>}\n\t */\n\tselectList(sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(options, (error, results, fields) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tthis.lastFields = fields;\n\t\t\t\t\tconst name = fields[0].name;\n\t\t\t\t\tconst list = [];\n\t\t\t\t\tresults.forEach(result => list.push(result[name]));\n\t\t\t\t\tresolve(list);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Return records all grouped by one of the column's values\n\t * @param {String} groupField  The name of the field to group by\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Array>}\n\t */\n\tselectGrouped(groupField, sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(options, (error, results, fields) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tthis.lastFields = fields;\n\t\t\t\t\tconst hash = {};\n\t\t\t\t\tresults.forEach(result => {\n\t\t\t\t\t\tif (!hash[result[groupField]]) {\n\t\t\t\t\t\t\thash[result[groupField]] = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\thash[result[groupField]].push(result);\n\t\t\t\t\t});\n\t\t\t\t\tresolve(hash);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Return records all indexed by one of the column's values\n\t * @param {String} indexField  The name of the field to index by\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Array>}\n\t */\n\tselectIndexed(indexField, sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(options, (error, results, fields) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tthis.lastFields = fields;\n\t\t\t\t\tconst hash = {};\n\t\t\t\t\tresults.forEach(result => {\n\t\t\t\t\t\thash[result[indexField]] = result;\n\t\t\t\t\t});\n\t\t\t\t\tresolve(hash);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Return first result row for the given SELECT statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Object>}\n\t */\n\tselectFirst(sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(options, (error, results, fields) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tthis.lastFields = fields;\n\t\t\t\t\tresolve(results[0]);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Return first column value for the first result row for the given SELECT statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Number|String>}\n\t */\n\tselectValue(sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(options, (error, results, fields) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tthis.lastFields = fields;\n\t\t\t\t\tconst name = fields[0].name;\n\t\t\t\t\tresolve(results[0][name]);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Run the given SELECT statement wrapped in a SELECT EXISTS query\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Boolean>}  True if it exists, false otherwise\n\t */\n\tselectExists(sql, ...bindVars) {\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\toptions.sql = `SELECT EXISTS (${options.sql}) AS does_it_exist`;\n\t\treturn this.selectValue(options).then(Boolean);\n\t}\n\n\t/**\n\t * Run the given INSERT statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Number>}  The id of the last inserted record\n\t */\n\tinsert(sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(options, (error, results) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(results.insertId);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Run the given UPDATE statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Number>}  The number of rows affected by the statement\n\t */\n\tupdate(sql, ...bindVars) {\n\t\tthis.connectOnce();\n\t\tconst options = this.bindArgs(sql, bindVars);\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.lastQuery = this.connection.query(options, (error, results) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(results.changedRows);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Run the given DELETE statement\n\t * @param {String} sql  The SQL to run\n\t * @param {...*} bindVars  The values to bind to the each question mark or named binding\n\t * @return {Promise<Array>}\n\t */\n\tdelete(sql, ...bindVars) {\n\t\treturn this.update(sql, ...bindVars);\n\t}\n\n\t/**\n\t * Build a SELECT statement and return result rows\n\t * @param {String} table  The name of the table\n\t * @param {Array} fields  An array of field names to select\n\t * @param {Object} params  Params to construct the WHERE clause\n\t * @param {String} extra  Additional raw SQL such as GROUP BY, ORDER BY, or LIMIT\n\t * @return {Promise<Array>}  The result rows\n\t */\n\tselectFrom(table, fields = [], params = {}, extra = '') {\n\t\tthis.connectOnce();\n\t\tconst escFields = fields.map(field => mysql.escapeId(field));\n\t\tconst escFieldsString = fields.length ? escFields.join(', ') : '*';\n\t\tconst escTable = mysql.escapeId(table);\n\t\tconst escWhere = this.buildWheres(params) || '1';\n\t\tconst sql = `SELECT ${escFieldsString} FROM ${escTable} WHERE ${escWhere} ${extra}`.trim();\n\t\treturn this.select(sql);\n\t}\n\n\t/**\n\t * Select the record with the given id\n\t * @param {String} table  The name of the table from which to select\n\t * @param {String} id  The value of the id column\n\t * @return {Promise<Number>}\n\t */\n\tselectId(table, id) {\n\t\treturn this.selectRecordByKey(table, 'id', id);\n\t}\n\n\t/**\n\t * Select the record with the given UUID\n\t * @param {String} table  The name of the table from which to select\n\t * @param {String} uuid  The value of the uuid column\n\t * @return {Promise<String>}\n\t */\n\tselectUuid(table, uuid) {\n\t\treturn this.selectRecordByKey(table, 'uuid', uuid);\n\t}\n\n\t/**\n\t * Select the record with the given UUID\n\t * @param {String} table  The name of the table from which to select\n\t * @param {String} column  The name of the column from which to select\n\t * @param {String} value  The value of the record for that column\n\t * @return {Promise<Object>}\n\t */\n\tselectRecordByKey(table, column, value) {\n\t\tconst escTable = mysql.escapeId(table);\n\t\tconst escColumn = mysql.escapeId(column);\n\t\treturn this.selectFirst(`SELECT * FROM ${escTable} WHERE ${escColumn} = ?`, value);\n\t}\n\n\t/**\n\t * Find a record or add a new one\n\t * @param {String} table  The name of the table from which to select\n\t * @param {String} column  The name of the column from which to select\n\t * @param {String} value  The value of the record for that column\n\t * @param {Object} newValues  The values to use to insert if the record doesn't exist\n\t * @return {Promise<Number>}  The existing id or the new id\n\t */\n\tfindIdOrCreate(table, column, value, newValues = {}) {\n\t\tconst escTable = mysql.escapeId(table);\n\t\tconst escColumn = mysql.escapeId(column);\n\t\treturn this.selectFirst(`SELECT id FROM ${escTable} WHERE ${escColumn} = ?`, value).then(id => {\n\t\t\tif (id) {\n\t\t\t\treturn id;\n\t\t\t}\n\t\t\treturn this.insertInto(table, { [column]: value, ...newValues });\n\t\t});\n\t}\n\n\t/**\n\t * Build an INSERT statement and run it\n\t * @param {String} table  The name of the table\n\t * @param {Object} values  column-value pairs to insert\n\t * @return {Promise<Number>}  Id of the last inserted record\n\t */\n\tinsertInto(table, values) {\n\t\tthis.connectOnce();\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst escTable = mysql.escapeId(table);\n\t\t\t// see https://www.npmjs.com/package/mysql#escaping-query-values\n\t\t\tconst sql = `INSERT INTO ${escTable} SET ?`;\n\t\t\tthis.lastQuery = this.connection.query(sql, values, error => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tthis.connection.query('SELECT LAST_INSERT_ID() AS id', (insertError, insertResults) => {\n\t\t\t\t\t\tif (insertError) {\n\t\t\t\t\t\t\treject(insertError);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(insertResults[0].id);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Build an UPDATE statement and run it\n\t * @param {String} table  The name of the table\n\t * @param {Object} set  An array of column => value pairs to update\n\t * @param {Object} where  Params to construct the WHERE clause\n\t * @return {Promise<Number>}  Number of rows affected\n\t */\n\tupdateTable(table, set, where = {}) {\n\t\tthis.connectOnce();\n\t\tconst escTable = mysql.escapeId(table);\n\t\tconst escWhere = this.buildWheres(where);\n\t\tconst sql = `UPDATE ${escTable} SET ? WHERE ${escWhere}`;\n\t\treturn this.select(sql, set);\n\t}\n\n\t/**\n\t * Construct a delete query and run\n\t * @param {String} table  The name of the table from which to delete\n\t * @param {Object} where  WHERE conditions on which to delete\n\t * @param {Number} limit  Limit deletion to this many records\n\t * @return {Promise<Number>}  Number of affected rows\n\t */\n\tdeleteFrom(table, where, limit = null) {\n\t\tthis.connectOnce();\n\t\tconst escTable = mysql.escapeId(table);\n\t\tconst escWhere = this.buildWheres(where);\n\t\tlet sql = `DELETE FROM ${escTable} WHERE ${escWhere}`;\n\t\tif (limit > 0) {\n\t\t\tsql = `${sql}LIMIT ${limit}`;\n\t\t}\n\t\treturn this.delete(sql);\n\t}\n\n\t/**\n\t * Build a where clause from an object of field-value pairs\n\t * @param {Object} wheres  An object with field-value pairs (field may be field space operator)\n\t * @return {String}\n\t */\n\tbuildWheres(wheres) {\n\t\tconst clauses = [];\n\t\tfor (const field in wheres) {\n\t\t\tif (!wheres.hasOwnProperty(field)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclauses.push(this.buildWhere(field, wheres[field]));\n\t\t}\n\t\treturn clauses.length ? clauses.join(' AND ') : '1';\n\t}\n\n\t/**\n\t * Construct where clause element from the given field and value\n\t * @param {String} field  The field or field space operator\n\t * @param {*} value  The value to bind\n\t * @return {String}\n\t * @example\n\t * db.buildWhere('start_date BETWEEN', array('2012-01-01','2013-01-01'));\n\t * db.buildWhere('start_date >', '2013-01-01');\n\t * db.buildWhere('start_date !=', '2013-01-01');\n\t * db.buildWhere('start_date', null); // `start_date` IS NULL\n\t * db.buildWhere('start_date !=', null); // `start_date` IS NOT NULL\n\t * db.buildWhere('id', array(1,2,3)); // id IN (1,2,3)\n\t * db.buildWhere('id !=', array(1,2,3)); // id NOT IN (1,2,3)\n\t */\n\tbuildWhere(field, value) {\n\t\tlet [name, operator] = field.split(' ');\n\t\tname = mysql.escapeId(name);\n\t\toperator = operator ? operator.toUpperCase() : '=';\n\t\tif (operator === 'BETWEEN') {\n\t\t\tconst val0 = mysql.escape(value[0]);\n\t\t\tconst val1 = mysql.escape(value[1]);\n\t\t\treturn `${name} BETWEEN ${val0} AND ${val1}`;\n\t\t} else if (value === null) {\n\t\t\treturn operator === '=' ? `${name} IS NULL` : `${name} IS NOT NULL`;\n\t\t} else if (Array.isArray(value)) {\n\t\t\tconst values = value.map(val => mysql.escape(val));\n\t\t\treturn operator === '=' || operator === 'IN'\n\t\t\t\t? `${name} IN(${values})`\n\t\t\t\t: `${name} NOT IN(${values})`;\n\t\t}\n\t\tconst escVal = mysql.escape(value);\n\t\treturn `${name} ${operator} ${escVal}`;\n\t}\n\n\t/**\n\t * Bind an array of arguments to a query\n\t * @param {String} sql  The base SQL query\n\t * @param {Array} args  An array of values to bind\n\t * @return {String}\n\t * @example\n\t * db.select('SELECT * FROM users WHERE id = ?', 100);\n\t * db.bindArgs(array('SELECT * FROM users WHERE id = ?', 100)); // SELECT * FROM users WHERE id = '100'\n\t * db.select('SELECT * FROM users WHERE id = :id', array('id'=>100));\n\t * db.bindArgs(array('SELECT * FROM users WHERE id = :id', array('id'=>100))); // SELECT * FROM users WHERE id = '100'\n\t */\n\tbindArgs(sql, args) {\n\t\tconst options = typeof sql == 'object' ? sql : { sql };\n\t\tif (typeof options.sql !== 'string') {\n\t\t\toptions.sql = '';\n\t\t}\n\t\tif (!Array.isArray(args)) {\n\t\t\treturn options;\n\t\t}\n\t\targs.forEach(arg => {\n\t\t\tif (arg && typeof arg === 'object' && !Array.isArray(arg)) {\n\t\t\t\toptions.sql = options.sql.replace(/:([\\w_]+)/g, ($0, $1) => {\n\t\t\t\t\tif (arg.hasOwnProperty($1)) {\n\t\t\t\t\t\treturn mysql.escape(arg[$1]);\n\t\t\t\t\t}\n\t\t\t\t\treturn $0;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\toptions.sql = options.sql.replace('?', mysql.escape(arg));\n\t\t\t}\n\t\t});\n\t\treturn options;\n\t}\n\n\t/**\n\t * Escape a value for use in a raw query and surround with apostrophes\n\t * @param {*} value  The value to escape\n\t * @return {String}\n\t */\n\tescape(value) {\n\t\treturn mysql.escape(value);\n\t}\n\n\t/**\n\t * Escape a value for use in a raw query without apostrophes\n\t * @param {*} value  The value to escape\n\t * @return {String}\n\t */\n\tescapeQuoteless(value) {\n\t\treturn mysql.escape(value).slice(1, -1);\n\t}\n\n\ttpl() {\n\t\tfunction toSql(templateData, variables) {\n\t\t\tlet s = templateData[0];\n\t\t\tvariables.forEach((variable, i) => {\n\t\t\t\ts += mysql.escape(variable);\n\t\t\t\ts += templateData[i + 1];\n\t\t\t});\n\t\t\treturn s;\n\t\t}\n\t\tconst supported = [\n\t\t\t'select',\n\t\t\t'selectFirst',\n\t\t\t'selectList',\n\t\t\t'selectHash',\n\t\t\t'selectValue',\n\t\t\t'insert',\n\t\t\t'update',\n\t\t\t'delete',\n\t\t];\n\t\tconst functions = {};\n\t\tsupported.forEach(name => {\n\t\t\tfunctions[name] = (templateData, ...variables) => {\n\t\t\t\treturn this[name](toSql(templateData, variables));\n\t\t\t};\n\t\t});\n\t\treturn functions;\n\t}\n\n\tmock(when, data) {\n\t\tif (this.mocks.length === 0) {\n\t\t\tthis.connection = {\n\t\t\t\tconnect: function() {},\n\t\t\t\tquery: function(options, values, cb) {\n\t\t\t\t\tfor (mock of this.mocks) {\n\t\t\t\t\t\tconst { when, data } = mock;\n\t\t\t\t\t\tif (typeof when === 'string') {\n\t\t\t\t\t\t\tif (options.sql === when) {\n\t\t\t\t\t\t\t\tcb(data);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (when instanceof RegExp) {\n\t\t\t\t\t\t\tif (when.test(options.sql)) {\n\t\t\t\t\t\t\t\tcb(data);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (typeof when === 'function') {\n\t\t\t\t\t\t\tif (when(options.sql)) {\n\t\t\t\t\t\t\t\tcb(data);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcb(data);\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\t\tthis.mocks.push({ when, data });\n\t\treturn this;\n\t}\n}\n","import capitalize from 'lodash.capitalize';\nimport camelCase from 'lodash.camelcase';\nimport upperFirst from 'lodash.upperfirst';\nimport trim from 'lodash.trim';\n\n/**\n * Parse SQL and populate onto a Select query object\n */\nexport class Parser {\n\t/**\n\t * Create a new instance\n\t * @param {Select} query  A Select object on which to build parsed conditions\n\t */\n\tconstructor(query) {\n\t\tthis.query = query;\n\t}\n\n\t/**\n\t * Strip single-line and multi-line comment blocks\n\t * @param {String} sql  The SQL string\n\t * @return {String}\n\t */\n\t_stripComments(sql) {\n\t\t// multiline comments\n\t\tsql = sql.replace(/\\/\\*[\\s\\S]*?\\*\\//g, '');\n\t\t// single line comments -- dashes\n\t\tsql = sql.replace(/--([\\r\\n]|\\s+[^\\r\\n]+[\\r\\n])/g, '');\n\t\t// single line comments #hashes\n\t\tsql = sql.replace(/#[^\\r\\n]+[\\r\\n]/g, '');\n\t\treturn sql;\n\t}\n\n\t/**\n\t * Before splitting into SQL clauses, extract some regex-able subqueries\n\t * @param {String} sql  The unparsed sql string\n\t * @return {Object}  An array with new sql and subqueries\n\t */\n\t_extractSubqueries(sql) {\n\t\tconst subqueries = {};\n\t\tlet i = 0;\n\t\tconst extractor = $0 => {\n\t\t\tconst placeholder = `~~SUBQUERY_${i++}~~`;\n\t\t\tsubqueries[placeholder] = $0;\n\t\t\treturn placeholder;\n\t\t};\n\t\t// subselect in FROM clause\n\t\tsql = sql.replace(/\\(\\s*SELECT\\s+.+\\)\\s+AS\\s+[^\\s,]+/, extractor);\n\t\t// IF() in FROM clause\n\t\tsql = sql.replace(/\\bIF\\s*\\(.+\\)\\s+AS\\s+[^\\s,]+/, extractor);\n\t\t// IN (SELECT *) in JOINs, WHERE or HAVING\n\t\tsql = sql.replace(/\\bIN\\s*\\(SELECT\\s.+?\\)/, extractor);\n\t\treturn { sql, subqueries };\n\t}\n\n\t/**\n\t * Inject column subqueries back into this object\n\t * @param {Object} subqueries  The lookup of extracted subqueries\n\t */\n\t_injectSubqueries(subqueries) {\n\t\tconst replacer = $0 => {\n\t\t\treturn subqueries[$0] || $0;\n\t\t};\n\t\tconst mapper = clause => {\n\t\t\treturn clause.replace(/~~SUBQUERY_\\d+~~/g, replacer);\n\t\t};\n\t\tthis.query._columns = this.query._columns.map(replacer);\n\t\tthis.query._joins = this.query._joins.map(mapper);\n\t\tthis.query._wheres = this.query._wheres.map(mapper);\n\t\tthis.query._havings = this.query._havings.map(mapper);\n\t}\n\n\t/**\n\t * Split SQL into clauses (used by ::parse())\n\t * @param {String} sql  The SQL to split\n\t * @return {String[]}\n\t */\n\t_split(sql) {\n\t\tconst splitter = /\\b(SELECT|FROM|(?:INNER |LEFT OUTER |RIGHT OUTER |LEFT |RIGHT |CROSS |FULL |FULL OUTER )JOIN|WHERE|GROUP BY|HAVING|ORDER BY|LIMIT|OFFSET)\\b/i;\n\t\treturn sql.split(splitter);\n\t}\n\n\t/**\n\t * Get a QuickSelect object representing the given SQL SELECT statement\n\t * @param {String} rawSql  The raw SQL for the SELECT statement\n\t * @return {Boolean}\n\t */\n\tparse(rawSql) {\n\t\tconst stripped = this._stripComments(rawSql);\n\t\tconst { sql, subqueries } = this._extractSubqueries(stripped);\n\t\tconst expressions = this._split(sql);\n\t\tlet i = 1;\n\t\twhile (i < expressions.length) {\n\t\t\tconst rawKeyword = expressions[i++].trim();\n\t\t\tconst keyword = upperFirst(camelCase(rawKeyword));\n\t\t\tconst clause = expressions[i++].trim();\n\t\t\tconst handler = `_handle${keyword}`;\n\t\t\tthis[handler](clause);\n\t\t}\n\t\tthis._injectSubqueries(subqueries);\n\t\treturn true;\n\t}\n\n\t_handleSelect(clause) {\n\t\tlet columns = clause.split(/s*,s*/);\n\t\t// now handle parenthesis expressions that contain commas\n\t\tlet buffer = '';\n\t\tcolumns.forEach((column, i) => {\n\t\t\tif (i === 0) {\n\t\t\t\tconst optionRegex = /^(SQL_CALC_FOUND_ROWS)\\s+/i;\n\t\t\t\tconst match = column.match(optionRegex);\n\t\t\t\tif (match) {\n\t\t\t\t\tthis.query.option(match[1]);\n\t\t\t\t\tcolumn = column.replace(optionRegex, '');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (buffer.length) {\n\t\t\t\t// we are in the middle of an expression containing parenthesis\n\t\t\t\tbuffer += column + ',';\n\t\t\t\tif (column.indexOf(')') > 0) {\n\t\t\t\t\t// we have an end parenthesis\n\t\t\t\t\tbuffer = '';\n\t\t\t\t}\n\t\t\t} else if (column.match(/\\([^)]+$/)) {\n\t\t\t\tbuffer = column + ',';\n\t\t\t} else {\n\t\t\t\tthis.query.column(column.trim());\n\t\t\t}\n\t\t});\n\t}\n\n\t_handleFrom(clause) {\n\t\tconst tables = clause.split(/\\s*,\\s*/);\n\t\ttables.forEach(table => this.query.table(table));\n\t}\n\n\t_handleJoin(clause) {\n\t\tthis.query.innerJoin(clause);\n\t}\n\n\t_handleInnerJoin(clause) {\n\t\tthis.query.innerJoin(clause);\n\t}\n\n\t_handleLeftJoin(clause) {\n\t\tthis.query.leftJoin(clause);\n\t}\n\n\t_handleLeftOuterJoin(clause) {\n\t\tthis.query.leftOuterJoin(clause);\n\t}\n\n\t_handleRightJoin(clause) {\n\t\tthis.query.rightJoin(clause);\n\t}\n\n\t_handleRightOuterJoin(clause) {\n\t\tthis.query.rightOuterJoin(clause);\n\t}\n\n\t_handleCrossJoin(clause) {\n\t\tthis.query.crossJoin(clause);\n\t}\n\n\t_handleFullJoin(clause) {\n\t\tthis.query.fullJoin(clause);\n\t}\n\n\t_handleFullOuterJoin(clause) {\n\t\tthis.query.fullOuterJoin(clause);\n\t}\n\n\t_handleWhere(clause) {\n\t\tif (/^(1|'1'|true)$/i.test(clause)) {\n\t\t\tthis.query._wheres.push(clause);\n\t\t} else {\n\t\t\tthis._handleConditions('where', clause);\n\t\t}\n\t}\n\n\t_handleHaving(clause) {\n\t\tthis._handleConditions('having', clause);\n\t}\n\n\t/**\n\t * Build a conditions list\n\t * @param {String} type  Either WHERE or HAVING\n\t * @param {String} clause  The expressions following the type keyword\n\t */\n\t_handleConditions(type, clause) {\n\t\tconst andGroups = clause.split(/\\bAND\\b/i);\n\t\tandGroups.forEach(andGroup => {\n\t\t\tconst orPieces = andGroup.split(/\\bOR\\b/i).map(trim);\n\t\t\tif (orPieces.length === 1) {\n\t\t\t\t// no OR operators\n\t\t\t\tconst fn = type; // either where or having\n\t\t\t\tthis.query[fn](orPieces[0]);\n\t\t\t} else {\n\t\t\t\t// some OR operators\n\t\t\t\tconst orFn = 'or' + capitalize(type); // either orWhere or orHaving\n\t\t\t\tthis.query[orFn](orPieces);\n\t\t\t}\n\t\t});\n\t}\n\n\t_handleGroupBy(clause) {\n\t\tconst columns = clause.split(/\\s*,\\s*/);\n\t\tcolumns.forEach(column => this.query.groupBy(column));\n\t}\n\n\t_handleOrderBy(clause) {\n\t\tconst columns = clause.split(/\\s*,\\s*/);\n\t\tcolumns.forEach(column => this.query.orderBy(column));\n\t}\n\n\t_handleLimit(clause) {\n\t\tthis.limit(clause);\n\t}\n\n\t_handleOffset(clause) {\n\t\tthis.offset(clause);\n\t}\n}\n","import { Parser } from '../Parser/Parser.js';\nimport { Db } from '../Db/Db.js';\nimport cloneDeep from 'lodash.clonedeep';\nimport escapeRegExp from 'lodash.escaperegexp';\nimport forOwn from 'lodash.forown';\nimport uniq from 'lodash.uniq';\nimport substrCount from 'quickly-count-substrings';\nimport mysql from 'mysql';\n\n/**\n * Build a select query\n * Class Select\n */\nexport class Select {\n\tparse(sql) {\n\t\tthis.reset();\n\t\tconst parser = new Parser(this);\n\t\tparser.parse(sql);\n\t\treturn this;\n\t}\n\n\tstatic parse(sql) {\n\t\tconst db = Db.factory();\n\t\treturn Select.init(db).parse(sql);\n\t}\n\n\t/**\n\t * Select constructor\n\t */\n\tconstructor(Db) {\n\t\tthis.db = Db;\n\t\tthis.reset();\n\t}\n\n\t/**\n\t * Shortcut to initialize without the `new` keyword\n\t * @return {Select}\n\t */\n\tstatic init(Db) {\n\t\treturn new Select(Db);\n\t}\n\n\t/**\n\t * Get the SQL as a pretty-printed string\n\t * @return {String}\n\t */\n\ttoString() {\n\t\tconst lines = [\n\t\t\t'SELECT',\n\t\t\tthis._options.length ? `  ${this._options.join('\\n  ')}` : null,\n\t\t\tthis._columns.length ? `  ${this._columns.join(',\\n  ')}` : '  *\\n',\n\t\t\t`FROM ${this._tables.join(', ')}`,\n\t\t\tthis._joins.length ? this._joins.join('\\n') : null,\n\t\t\tthis._wheres.length ? `WHERE ${this._wheres.join('\\n  AND ')}` : null,\n\t\t\tthis._groupBys.length ? `GROUP BY ${this._groupBys.join(',\\n  ')}` : null,\n\t\t\tthis._havings.length ? `HAVING ${this._havings.join('\\n  AND ')}` : null,\n\t\t\tthis._orderBys.length ? `ORDER BY ${this._orderBys.join(',\\n  ')}` : null,\n\t\t];\n\t\tif (this._page > 0) {\n\t\t\tconst offset = (this._page - 1) * this._limit;\n\t\t\tlines.push(`LIMIT ${this._limit}`);\n\t\t\tlines.push(`OFFSET ${offset}`);\n\t\t} else {\n\t\t\tif (this._limit > 0) {\n\t\t\t\tlines.push(`LIMIT ${this._limit}`);\n\t\t\t}\n\t\t\tif (this._offset > 0) {\n\t\t\t\tlines.push(`OFFSET ${this._offset}`);\n\t\t\t}\n\t\t}\n\n\t\treturn lines\n\t\t\t.filter(Boolean)\n\t\t\t.join('\\n')\n\t\t\t.trim();\n\t}\n\n\t/**\n\t * Get the SQL as a one-line string\n\t * @return {String}\n\t */\n\tnormalized() {\n\t\tconst lines = [\n\t\t\t'SELECT',\n\t\t\tthis._options.length ? this._options.join(' ') : null,\n\t\t\tthis._columns.length ? this._columns.join(', ') : '*',\n\t\t\t`FROM ${this._tables.join(', ')}`,\n\t\t\tthis._joins.length ? this._joins.join(' ') : null,\n\t\t\tthis._wheres.length ? `WHERE ${this._wheres.join(' AND ')}` : null,\n\t\t\tthis._groupBys.length ? `GROUP BY ${this._groupBys.join(', ')}` : null,\n\t\t\tthis._havings.length ? `HAVING ${this._havings.join(' AND ')}` : null,\n\t\t\tthis._orderBys.length ? `ORDER BY ${this._orderBys.join(', ')}` : null,\n\t\t];\n\n\t\tif (this._page > 0) {\n\t\t\tconst offset = (this._page - 1) * this._limit;\n\t\t\tlines.push(`LIMIT ${this._limit}`);\n\t\t\tlines.push(`OFFSET ${offset}`);\n\t\t} else {\n\t\t\tif (this._limit > 0) {\n\t\t\t\tlines.push(`LIMIT ${this._limit}`);\n\t\t\t}\n\t\t\tif (this._offset > 0) {\n\t\t\t\tlines.push(`OFFSET ${this._offset}`);\n\t\t\t}\n\t\t}\n\n\t\treturn lines\n\t\t\t.filter(Boolean)\n\t\t\t.join(' ')\n\t\t\t.trim();\n\t}\n\n\t/**\n\t * @param {String|Array} [field]  If given, reset the given component(s), otherwise reset all query components\n\t *     Valid components: option, column, table, where, orWhere, having, groupBy, orderBy, limit, offset, page\n\t * @return {Select}\n\t */\n\treset(field = null) {\n\t\tif (Array.isArray(field)) {\n\t\t\tfield.forEach(name => this.reset(name));\n\t\t\treturn this;\n\t\t}\n\t\tif (field) {\n\t\t\tlet prop = '_' + field.replace(/s$/, '');\n\t\t\tif (\n\t\t\t\t['option', 'column', 'table', 'where', 'having', 'groupBy', 'orderBy'].indexOf(field) > -1\n\t\t\t) {\n\t\t\t\tprop += 's';\n\t\t\t}\n\t\t\tthis[prop] = ['limit', 'offset', 'page'].indexOf(field) > -1 ? null : [];\n\t\t} else {\n\t\t\tthis._hasOne = [];\n\t\t\tthis._belongsTo = [];\n\t\t\tthis._hasMany = [];\n\t\t\tthis._habtm = [];\n\t\t\tthis._options = [];\n\t\t\tthis._columns = [];\n\t\t\tthis._tables = [];\n\t\t\tthis._joins = [];\n\t\t\tthis._wheres = [];\n\t\t\tthis._havings = [];\n\t\t\tthis._groupBys = [];\n\t\t\tthis._orderBys = [];\n\t\t\tthis._limit = null;\n\t\t\tthis._offset = null;\n\t\t\tthis._page = null;\n\t\t\tthis._bound = [];\n\t\t}\n\t\treturn this;\n\t}\n\n\t// \t\t/**\n\t// \t\t * Internal function for defining a relationship for fetching dependent or related tate\n\t// \t\t * @param {String} type  One of hasOne, hasMany, habtm\n\t// \t\t * @param array $spec  The specification for the relationship\n\t// \t\t * @return {Select}\n\t// \t\t */\n\t// \t\trelate($type, $spec) {\n\t// \t\t\tif ($type == 'habtm' || $type == 'hasAndBelongsToMany') {\n\t// \t\t\t\tthis.relationships[] = [\n\t// \t\t\t\t\t'key' => $spec['thisProperty'],\n\t// \t\t\t\t\t'type' => 'habtm',\n\t// \t\t\t\t\t'thisProperty' => @$spec['key'] ?: $spec['thisProperty'],\n\t// \t\t\t\t\t'options' => $spec\n\t// \t\t\t];\n\t// \t\t\t}\n\t// \t\t\telseif ($type == 'hasOne') {\n\t// \t\t\t\t$spec['key'] = @$spec['key'] ?: preg_replace('/^\\S+ as (\\S+)$/i', '$1', $spec['thisProperty']);\n\t// \t\t\t\t$spec['type'] = 'hasOne';\n\t// \t\t\t\tthis.relationships[] = $spec;\n\t// \t\t\t}\n\t// \t\telse {\n\t// \t\t\t\t$spec['key'] = @$spec['key'] ?: $spec['thisProperty'];\n\t// \t\t\t\t$spec['type'] = $type;\n\t// \t\t\t\tthis.relationships[] = $spec;\n\t// \t\t\t}\n\t// \t\t\treturn this;\n\t// \t\t}\n\t//\n\t// \t\t/**\n\t// \t\t * Specify to fetch dependent data of the given type\n\t// \t\t * @param {String} key  The name of the relationship as previously defined\n\t// \t\t * @return {Select}\n\t// \t\t */\n\t// \t\tcontain($key) {\n\t// \t\t\tif ($key == 'ALL') {\n\t// \t\t\t\tforeach (this.relationships as $rel) {\n\t// \t\t\t\t\tthis.{'_' . $rel['type']}[] = $rel;\n\t// \t\t\t\t}\n\t// \t\t\t\treturn this;\n\t// \t\t\t}\n\t// \t\t\tforeach (this.relationships as $rel) {\n\t// \t\t\t\tif ($key == $rel['key']) {\n\t// \t\t\t\t\tthis.{'_' . $rel['type']}[] = $rel;\n\t// \t\t\t\t\treturn this;\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// //\t\tQuickLogger::write('hasOne', pprt($key, this.relationships));\n\t// \t\t\ttrigger_error(\"Unknown contain key `$key`\", E_USER_WARNING);\n\t// \t\t\treturn this;\n\t// \t\t}\n\t//\n\thasOne(thisProperty, thatTableAndColumn) {\n\t\tthis._hasOne.push({ thisProperty, thatTableAndColumn });\n\t\treturn this;\n\t}\n\n\tbelongsTo(thisProperty, thatTableAndColumn) {\n\t\tthis._belongsTo.push({ thisProperty, thatTableAndColumn });\n\t\treturn this;\n\t}\n\n\thasMany(thisProperty, thatTableAndColumn) {\n\t\tthis._hasMany.push({ thisProperty, thatTableAndColumn });\n\t\treturn this;\n\t}\n\n\thabtm(thisProperty, idsColumn, join) {\n\t\tconst matchJoinFirst = join.match(/(?:LEFT JOIN\\s*)?(.+)\\s+ON\\s+\\1\\.id\\s*=\\s*(.+)\\.(.+)/);\n\t\tconst matchJoinSecond = join.match(/(?:LEFT JOIN\\s*)?(.+)\\s+ON\\s+(.+)\\.(.+)\\s*=\\s*\\1\\.id/);\n\t\tif (!matchJoinFirst && !matchJoinSecond) {\n\t\t\tthrow new Error(\n\t\t\t\t`Select: Unknown join pattern: \"${join}\". Expecting format \"joinTable ON joinTable.id = throughTable.foreignColumn\"`\n\t\t\t);\n\t\t}\n\t\tlet [_, joinTable, throughTable, foreignColumn] = matchJoinFirst || matchJoinSecond;\n\t\tthis._habtm.push({\n\t\t\tthisProperty,\n\t\t\tidsColumn,\n\t\t\tjoin,\n\t\t\tjoinTable,\n\t\t\tthroughTable,\n\t\t\tforeignColumn,\n\t\t});\n\t\treturn this;\n\t}\n\n\thasAndBelongsToMany(thisProperty, idsColumn, join) {\n\t\treturn this.habtm(thisProperty, idsColumn, join);\n\t}\n\n\t/**\n\t * Bind values by name to the query\n\t * @param {Object|String} placeholder  The name of the placeholder or an object with placeholder: value pairs\n\t * @param {*} [value=null]  The value to bind when placeholder is a string\n\t * @example\n\t *     query.bind('postId', 123); // replace :postId with '123'\n\t * @return {Select}\n\t */\n\tbind(placeholder, value = null) {\n\t\tif (typeof placeholder === 'object' && value === null) {\n\t\t\tforOwn(placeholder, (val, field) => {\n\t\t\t\tthis._bound[field] = val;\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t\tthis._bound[placeholder] = value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unbind a previously bound property\n\t * @param {String} placeholder\n\t * @return {Select}\n\t */\n\tunbind(placeholder) {\n\t\tif (Array.isArray(placeholder)) {\n\t\t\tplaceholder.forEach(p => this.unbind(p));\n\t\t\treturn this;\n\t\t}\n\t\tthis._bound[placeholder] = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Fetch records and splice in related data\n\t * @return {Promise<Array>}\n\t */\n\tasync fetch(options = {}) {\n\t\toptions.sql = this.toString();\n\t\tconst records = await this.db.select(options, this._bound);\n\t\tawait this._spliceHasOnes(records);\n\t\tawait this._spliceBelongsTos(records);\n\t\tawait this._spliceHasManys(records);\n\t\tawait this._spliceHabtms(records);\n\t\treturn records;\n\t}\n\n\t/**\n\t * Fetch the first matched record\n\t * @return {Object|null}\n\t */\n\tasync fetchFirst() {\n\t\tthis.limit(1);\n\t\tconst records = await this.fetch();\n\t\treturn Array.isArray(records) && records.length ? records[0] : null;\n\t}\n\n\t/**\n\t * Fetch each record as an array of values or an array of key-value pairs\n\t * @return {Promise<Object>}\n\t */\n\tfetchHash() {\n\t\treturn this.db.selectHash(this.toString(), this._bound);\n\t}\n\n\t/**\n\t * Fetch the value of first column of the first record\n\t * @return {Promise}\n\t */\n\tfetchValue() {\n\t\treturn this.db.selectValue(this.toString(), this._bound);\n\t}\n\n\t/**\n\t * Fetch values and index by the given field name\n\t * @param {String} byField  The field by which to index (e.g. id)\n\t * @return {Promise<Object>}\n\t */\n\tasync fetchIndexed(byField) {\n\t\tconst rs = await this.fetch();\n\t\tif (!Array.isArray(rs)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst indexed = {};\n\t\trs.forEach(r => (indexed[r[byField]] = r));\n\t\treturn indexed;\n\t}\n\n\t/**\n\t * Fetch values grouped by the given field name\n\t * @param {String} byField  The field by which to group\n\t * @example\n\t *      const query = Select.parse('SELECT * FROM comments');\n\t *      const byUser = query.fetchGrouped('user_id')\n\t *      // a key for each user id with an array of comments for each key\n\t * @return {Array}\n\t */\n\tasync fetchGrouped(byField) {\n\t\tconst rs = await this.fetch();\n\t\tif (!Array.isArray(rs)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst grouped = {};\n\t\trs.forEach(r => {\n\t\t\tif (!grouped[r[byField]]) {\n\t\t\t\tgrouped[r[byField]] = [];\n\t\t\t}\n\t\t\tgrouped[r[byField]].push(r);\n\t\t});\n\t\treturn grouped;\n\t}\n\n\t/**\n\t * Clone this object\n\t * @return {Select}\n\t */\n\tgetClone() {\n\t\tconst copy = new Select();\n\t\tcopy._hasOne = cloneDeep(this._hasOne);\n\t\tcopy._belongsTo = cloneDeep(this._belongsTo);\n\t\tcopy._hasMany = cloneDeep(this._hasMany);\n\t\tcopy._habtm = cloneDeep(this._habtm);\n\t\tcopy._options = cloneDeep(this._options);\n\t\tcopy._columns = cloneDeep(this._columns);\n\t\tcopy._tables = cloneDeep(this._tables);\n\t\tcopy._joins = cloneDeep(this._joins);\n\t\tcopy._wheres = cloneDeep(this._wheres);\n\t\tcopy._havings = cloneDeep(this._havings);\n\t\tcopy._groupBys = cloneDeep(this._groupBys);\n\t\tcopy._orderBys = cloneDeep(this._orderBys);\n\t\tcopy._limit = this._limit;\n\t\tcopy._offset = this._offset;\n\t\tcopy._page = this._page;\n\t\tcopy._bound = cloneDeep(this._bound);\n\t\treturn copy;\n\t}\n\n\t/**\n\t * Build a version of this query that simply returns COUNT(*)\n\t * @param {String} [countExpr=\"*\"]  Use to specify `DISTINCT colname` if needed\n\t * @return {Select}  The SQL query\n\t */\n\tgetFoundRowsQuery(countExpr = '*') {\n\t\tif (this._havings.length === 0) {\n\t\t\tconst clone = this.getClone();\n\t\t\tclone._columns = [`COUNT(${countExpr}) AS foundRows`];\n\t\t\tclone._options = [];\n\t\t\tclone._groupBys = [];\n\t\t\tclone._orderBys = [];\n\t\t\tclone._limit = null;\n\t\t\tclone._offset = null;\n\t\t\tclone._page = null;\n\t\t\treturn clone;\n\t\t} else {\n\t\t\tconst subquery = this.getClone();\n\t\t\tsubquery._limit = null;\n\t\t\tsubquery._offset = null;\n\t\t\tsubquery._page = null;\n\t\t\treturn subquery;\n\t\t}\n\t}\n\n\tgetFoundRowsSql(countExpr, normalize = false) {\n\t\tconst query = this.getFoundRowsQuery(countExpr);\n\t\tif (this._havings.length === 0) {\n\t\t\treturn normalize ? query.normalized() : query.toString();\n\t\t} else if (normalize) {\n\t\t\tconst subquerySql = query.normalized();\n\t\t\treturn `SELECT COUNT(*) AS foundRows FROM (${subquerySql}) AS subq`;\n\t\t} else {\n\t\t\tconst subquerySql = query.toString().replace(/\\n/g, '\\n\\t');\n\t\t\treturn `SELECT COUNT(*) AS foundRows FROM (\\n\\t${subquerySql}\\n) AS subq`;\n\t\t}\n\t}\n\n\t/**\n\t * Run a version of this query that simply returns COUNT(*)\n\t * @param {String} [countExpr=\"*\"]  Use to specify `DISTINCT colname` if needed\n\t * @return {Promise<Number>}  The number of rows or false on error\n\t */\n\tfoundRows(countExpr = '*') {\n\t\tconst sql = this.getFoundRowsSql(countExpr);\n\t\treturn this.db.selectValue(sql, this._bound);\n\t}\n\n\t/**\n\t * Internal method to fetch hasOne dependent data and splice it into the given result set\n\t * @param {Array} records  Records from .fetch()\n\t */\n\tasync _spliceHasOnes(records) {\n\t\tif (this._hasOne.length === 0 || records.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis._hasOne.forEach(async spec => {\n\t\t\tconst match = spec.thisProperty.match(/^([\\w_]+) AS ([\\w_]+)$/i);\n\t\t\tlet thisProperty;\n\t\t\tif (match) {\n\t\t\t\tthisProperty = match[2];\n\t\t\t\tspec.thisColumn = match[1];\n\t\t\t} else {\n\t\t\t\tthisProperty = spec.thisProperty.replace(/_id$/, '');\n\t\t\t}\n\t\t\tconst [table, column] = spec.thatTableAndColumn.split('.');\n\t\t\tlet ids = [];\n\t\t\trecords.forEach(r => {\n\t\t\t\tif (r[spec.thisColumn]) {\n\t\t\t\t\tids.push(r[spec.thisColumn]);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (ids.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tids = uniq(ids);\n\t\t\tconst query = Select.init()\n\t\t\t\t.table(table)\n\t\t\t\t.where(column, 'IN', ids);\n\t\t\tconst indexed = await query.fetchIndexed(column);\n\t\t\trecords.forEach(r => {\n\t\t\t\tr[thisProperty] = indexed[r[spec.thisColumn]] || null;\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Internal method to fetch belongTo dependent data and splice it into the given result set\n\t * @param {Array} records  The records from fetch()\n\t */\n\tasync _spliceBelongsTos(records) {\n\t\tif (this._belongsTo.length === 0 || records.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst ids = uniq(records.map(r => r.id));\n\t\tthis._belongsTo.forEach(async spec => {\n\t\t\tconst [table, column] = spec.thatTableAndColumn.split('.');\n\t\t\tconst indexed = await Select.init(this.db)\n\t\t\t\t.table(table)\n\t\t\t\t.where(column, 'IN', ids)\n\t\t\t\t.fetchIndexed(column);\n\t\t\trecords.forEach(r => {\n\t\t\t\tr[spec.thisPropery] = indexed[r.id] || null;\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Internal method to fetch hasMany dependent data and splice it into the given result set\n\t * @param {Array} records  The records from fetch()\n\t */\n\tasync _spliceHasManys(records) {\n\t\tif (this._hasMany.length === 0 || records.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst ids = uniq(records.map(r => r.id));\n\t\tthis._hasMany.forEach(async spec => {\n\t\t\tconst [table, column] = spec.thatTableAndColumn.split('.');\n\t\t\tconst query = Select.init()\n\t\t\t\t.table(table)\n\t\t\t\t.where(column, 'IN', ids);\n\t\t\tconst grouped = await query.fetchGrouped(column);\n\t\t\trecords.forEach(r => {\n\t\t\t\tr[spec.thisPropery] = grouped[r.id] || [];\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Internal method to fetch habtm dependent data and splice it into the given result set\n\t * @param {Array} records  The records from fetch()\n\t * @example\n\t * const query = Select.parse('SELECT * FROM users');\n\t * query.habtm(\n\t *   'hubs',\n\t *   'SELECT user_id, client_id FROM clients_users WHERE user_id IN (?)',\n\t *   'SELECT * FROM clients WHERE id IN(?)'\n\t * );\n\t */\n\tasync _spliceHabtms(records) {\n\t\tif (this._habtm.length === 0 || records.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst ids = uniq(records.map(r => r.id));\n\t\tthis._habtm.forEach(async spec => {\n\t\t\t// const { joinTableQuery, foreignTable } = spec;\n\t\t\t// const joinTableLookup = await this.db.selectGrouped('user_id', joinTableQuery, ids);\n\t\t\t// const foreignIds = uniq(values(joinTableLookup));\n\t\t\t// const foreignQuery = Select.init()\n\t\t\t// \t.table(foreignTable)\n\t\t\t// \t.where('id', 'IN', foreignIds);\n\t\t\t// const foreignRecords = await foreignQuery.fetchIndexed('id');\n\t\t\t// const { thisProperty, idsColumn, join, throughTable, subqueryHandler } = spec;\n\t\t\t// const subquery = Select.init()\n\t\t\t// \t.table(throughTable)\n\t\t\t// \t.leftJoin(join)\n\t\t\t// \t.where(`${throughTable}.${idsColumn}`, 'IN', ids);\n\t\t\t// if (subqueryHandler) {\n\t\t\t// \tsubqueryHandler(subquery);\n\t\t\t// }\n\t\t\t// const grouped = await subquery.fetchIndexed(idsColumn);\n\t\t\t// records.forEach(r => {\n\t\t\t// \tr[thisProperty] = grouped[r.id] || [];\n\t\t\t// });\n\t\t});\n\t}\n\n\t/**\n\t * Add an array of column names to fetch\n\t * @param {String[]} columnNames  The names of columns\n\t * @return {Select}\n\t */\n\tcolumns(columnNames) {\n\t\tthis._columns = [...this._columns, ...columnNames];\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a column name to fetch\n\t * @param {String} columnName  The name of the column\n\t * @return {Select}\n\t */\n\tcolumn(columnName) {\n\t\tthis._columns.push(columnName);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an option expression such as \"TOP 10\" or \"SQL_CALC_FOUND_ROWS\"\n\t * @param {String} optionExpression  Expression to go after \"SELECT\" and before column list\n\t * @return {Select}\n\t */\n\toption(optionExpression) {\n\t\tthis._options.push(optionExpression);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a table to the \"FROM\" clause (same as .from())\n\t * @param {String} tableName  The name of the table to query\n\t * @return {Select}\n\t */\n\ttable(tableName) {\n\t\tthis._tables.push(tableName);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a table to the \"FROM\" clause (same as .table())\n\t * @param {String} tableName  The name of the table to query\n\t * @return {Select}\n\t */\n\tfrom(tableName) {\n\t\tthis._tables.push(tableName);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an INNER JOIN expression (same as ->innerJoin())\n\t * @param {String} expression  The expression following the INNER JOIN keyword\n\t * @example query.join('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\tjoin(expression) {\n\t\tthis._joins.push(`INNER JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a LEFT JOIN expression\n\t * @param {String} expression  The expression following the LEFT JOIN keyword\n\t * @example query.leftJoin('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\tleftJoin(expression) {\n\t\tthis._joins.push(`LEFT JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a FULL JOIN expression\n\t * @param {String} expression  The expression following the FULL JOIN keyword\n\t * @example query.fullJoin('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\tfullJoin(expression) {\n\t\tthis._joins.push(`FULL JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a RIGHT JOIN expression\n\t * @param {String} expression  The expression following the RIGHT JOIN keyword\n\t * @example query.rightJoin('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\trightJoin(expression) {\n\t\tthis._joins.push(`RIGHT JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a CROSS JOIN expression\n\t * @param {String} expression  The expression following the CROSS JOIN keyword\n\t * @example query.join('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\tcrossJoin(expression) {\n\t\tthis._joins.push(`CROSS JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an INNER JOIN expression (same as ->join())\n\t * @param {String} expression  The expression following the INNER JOIN keyword\n\t * @example query.innerJoin('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\tinnerJoin(expression) {\n\t\tthis._joins.push(`INNER JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a LEFT OUTER JOIN expression\n\t * @param {String} expression  The expression following the LEFT OUTER JOIN keyword\n\t * @example query.leftOuterJoin('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\tleftOuterJoin(expression) {\n\t\tthis._joins.push(`LEFT OUTER JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a FULL OUTER JOIN expression\n\t * @param {String} expression  The expression following the FULL OUTER JOIN keyword\n\t * @example query.fullOuterJoin('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\tfullOuterJoin(expression) {\n\t\tthis._joins.push(`FULL OUTER JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a RIGHT OUTER JOIN expression\n\t * @param {String} expression  The expression following the RIGHT OUTER JOIN keyword\n\t * @example query.rightOuterJoin('posts p ON p.id = c.post_id');\n\t * @return {Select}\n\t */\n\trightOuterJoin(expression) {\n\t\tthis._joins.push(`RIGHT OUTER JOIN ${expression}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove a join condition with the specified table\n\t * @param {String|String[]} table  The name of the table or tables in the first part of the join statement\n\t * @return {Select}\n\t */\n\tunjoin(table) {\n\t\tif (Array.isArray(table)) {\n\t\t\ttable.forEach(t => this.unjoin(t));\n\t\t\treturn this;\n\t\t}\n\t\ttable = escapeRegExp(table);\n\t\tthis._joins = this._joins.filter(join => {\n\t\t\tconst regex = new RegExp(`^([A-Z]+) JOIN ${table}\\\\b`);\n\t\t\treturn !regex.test(join);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Utility function to add conditions for a clause (WHERE, HAVING)\n\t * @param {String} collection  The collection to add the clauses to\n\t * @param {Array} criteria  A list of expressions to stringify\n\t * @property {*} criteria[0]  The expression or name of the column on which to match\n\t * @property {*} [criteria[1]]  The comparison operator; defaults to \"=\"\n\t * @property {*} [criteria[2]]  The value to test against\n\t * @example  The following are equivalent\n\t *     this._conditions(this._wheres, ['deleted_at IS NULL']);\n\t *     this._conditions(this._wheres, ['deleted_at', null]);\n\t *     this._conditions(this._wheres, ['deleted_at', '=', null]);\n\t * @example  More examples\n\t *     this._conditions(this._wheres, ['fname', 'LIKE', 'joe']); // fname LIKE 'joe'\n\t *     this._conditions(this._wheres, ['fname', 'LIKE ?', 'joe']); // fname LIKE 'joe'\n\t *     this._conditions(this._wheres, ['fname LIKE %?%', 'joe']); // fname LIKE '%joe%'\n\t *     this._conditions(this._wheres, ['fname LIKE ?%', 'joe']); // fname LIKE 'joe%'\n\t *     this._conditions(this._wheres, ['fname', 'LIKE ?%', 'joe']); // fname LIKE 'joe%'\n\t *     this._conditions(this._wheres, ['price >', 10]); // price > '10'\n\t *     this._conditions(this._wheres, ['price', '>', 10]); // price > '10'\n\t *     this._conditions(this._wheres, ['price =', 10]); // price = '10'\n\t *     this._conditions(this._wheres, ['price !=', 10]); // price != '10'\n\t *     this._conditions(this._wheres, ['price', 10]); // price = '10'\n\t *     this._conditions(this._wheres, ['price', '=', 10]); // price = '10'\n\t *     this._conditions(this._wheres, ['price', '!=', 10]); // price != '10'\n\t *     this._conditions(this._wheres, ['price', 'BETWEEN', [10,20]]); // price BETWEEN '10' AND '20'\n\t *     this._conditions(this._wheres, ['price', 'NOT BETWEEN', [10,20]]); // price NOT BETWEEN '10' AND '20'\n\t *     this._conditions(this._wheres, ['price', [10,20]]); // price IN('10','20')\n\t *     this._conditions(this._wheres, ['price', '=', [10,20]]); // price IN('10','20')\n\t *     this._conditions(this._wheres, ['price', 'IN', [10,20]]); // price IN('10','20')\n\t *     this._conditions(this._wheres, ['price', 'NOT IN', [10,20]]); // price NOT IN('10','20')\n\t * @return {Select}\n\t */\n\t_conditions(collection, criteria) {\n\t\tif (typeof criteria === 'string') {\n\t\t\tcollection.push(criteria);\n\t\t\treturn this;\n\t\t}\n\t\tconst numArgs = criteria.length;\n\t\tlet [column, operator, value] = criteria;\n\t\tif (Array.isArray(column)) {\n\t\t\tcolumn.forEach(val => {\n\t\t\t\tthis._conditions(collection, [val]);\n\t\t\t});\n\t\t\treturn this;\n\t\t} else if (typeof column === 'object') {\n\t\t\tforOwn(column, (val, name) => {\n\t\t\t\tthis._conditions(collection, [name, val]);\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t\tif (/^\\w+$/.test(column)) {\n\t\t\tcolumn = mysql.escapeId(column);\n\t\t}\n\t\tif (numArgs === 1) {\n\t\t\t// condition is a stand-alone expression\n\t\t\t// e.g. \"SUM(price) > 10\"\n\t\t\tcollection.push(column);\n\t\t\treturn this;\n\t\t} else if (\n\t\t\tnumArgs === 2 &&\n\t\t\tArray.isArray(operator) &&\n\t\t\toperator.length > 0 &&\n\t\t\tsubstrCount(column, '?') === operator.length\n\t\t) {\n\t\t\tconst values = operator;\n\t\t\tlet i = 0;\n\t\t\tconst sql = column.replace(/(%)?\\?(%)?/, ($0, $1, $2) => {\n\t\t\t\tconst escNoQuotes = this.escapeQuoteless(values[i++]);\n\t\t\t\treturn `'${$1}${escNoQuotes}${$2}'`;\n\t\t\t});\n\t\t\tcollection.push(sql);\n\t\t\treturn this;\n\t\t} else if (numArgs === 2) {\n\t\t\t// condition has pairs of \"column + operator\" => \"value\"\n\t\t\t// e.g. [\"price >\", 10]\n\t\t\t// e.g. [\"status LIKE ?%\", 10]\n\t\t\tvalue = operator;\n\t\t\tconst parts = column.split(' ');\n\t\t\tcolumn = parts.shift();\n\t\t\toperator = parts.join(' ');\n\t\t}\n\t\tif (!operator) {\n\t\t\toperator = '=';\n\t\t}\n\t\toperator = operator.toLocaleUpperCase();\n\t\tconst likeMatch = operator.match(/^(LIKE|NOT LIKE)(?: (\\?|\\?%|%\\?|%\\?%))?$/);\n\t\tif (operator === 'NOT BETWEEN' || operator === 'BETWEEN') {\n\t\t\t// expect a two-item array\n\t\t\tconst from = mysql.escape(value[0]);\n\t\t\tconst to = mysql.escape(value[1]);\n\t\t\tcollection.push(`${column} ${operator} ${from} AND ${to}`);\n\t\t} else if (likeMatch) {\n\t\t\tconst quoteless = this.escapeQuoteless(value);\n\t\t\tlet quoted;\n\t\t\tif (likeMatch[2] === '?' || !likeMatch[2]) {\n\t\t\t\tquoted = `'${quoteless}'`;\n\t\t\t} else if (likeMatch[2] === '?%') {\n\t\t\t\tquoted = `'${quoteless}%'`;\n\t\t\t} else if (likeMatch[2] === '%?') {\n\t\t\t\tquoted = `'%${quoteless}'`;\n\t\t\t} else if (likeMatch[2] === '%?%') {\n\t\t\t\tquoted = `'%${quoteless}%'`;\n\t\t\t}\n\t\t\tcollection.push(`${column} ${likeMatch[1]} ${quoted}`);\n\t\t} else if (value === null) {\n\t\t\tcollection.push(operator === '=' ? `${column} IS NULL` : `${column} IS NOT NULL`);\n\t\t} else if (Array.isArray(value)) {\n\t\t\t// an array of values should be IN or NOT IN\n\t\t\tconst inVals = value.map(v => mysql.escape(v));\n\t\t\tconst joined = inVals.join(',');\n\t\t\tcollection.push(\n\t\t\t\toperator === '=' || operator === 'IN'\n\t\t\t\t\t? `${column} IN(${joined})`\n\t\t\t\t\t: `${column} NOT IN(${joined})`\n\t\t\t);\n\t\t} else if (operator === 'IN' || operator === 'NOT IN') {\n\t\t\t// in clause that is not array\n\t\t\tvalue = mysql.escape(value);\n\t\t\tcollection.push(`${column} ${operator} (${value})`);\n\t\t} else {\n\t\t\tvalue = mysql.escape(value);\n\t\t\tcollection.push(`${column} ${operator} ${value}`);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a group by column or expression\n\t * @param {String} column  The name of a column (or expression) to group by\n\t * @return {Select}\n\t */\n\tgroupBy(column) {\n\t\tthis._groupBys.push(column);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add WHERE clauses to conditions (See _conditions for usage)\n\t * @param {String} column  The expression or name of the column on which to match\n\t * @param {*} [operator]  The comparison operator; defaults to \"=\"\n\t * @param {*} [value]  The value to test against\n\t * @return {Select}\n\t */\n\twhere(...args) {\n\t\tthis._conditions(this._wheres, args);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a WHERE clause with a BETWEEN condition\n\t * @param {String} column  The column name\n\t * @param {Array} twoValueArray  The two values to be between\n\t * @return {Select}\n\t */\n\twhereBetween(column, twoValueArray) {\n\t\tif (twoValueArray[0] && twoValueArray[1]) {\n\t\t\tthis.where(column, 'BETWEEN', twoValueArray);\n\t\t} else if (twoValueArray[0]) {\n\t\t\tthis.where(column, '>=', twoValueArray[0]);\n\t\t} else if (twoValueArray.length > 1) {\n\t\t\tthis.where(column, '<=', twoValueArray[1]);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add WHERE conditions to place inside an OR block (See _conditions for usage)\n\t * @param {Array} conditions  A list where each item is an array with parameters that would be taken by where()\n\t * @return {Select}\n\t */\n\torWhere(conditions) {\n\t\tconst criteria = [];\n\t\tconditions.forEach(condition => {\n\t\t\tthis._conditions(criteria, condition);\n\t\t});\n\t\tconst joined = criteria.join(' OR ');\n\t\tif (joined.slice(0, 1) === '(' && joined.slice(-1) === ')') {\n\t\t\tthis.where(joined);\n\t\t} else {\n\t\t\tthis.where(`(${joined})`);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a HAVING condition (See _conditions for usage)\n\t * @param {String} column  The expression or name of the column on which to match\n\t * @param {*} [operator]  The comparison operator; defaults to \"=\"\n\t * @param {*} [value]  The value to test against\n\t * @return {Select}\n\t */\n\thaving(...args) {\n\t\tthis._conditions(this._havings, args);\n\t\treturn this;\n\t}\n\torHaving(conditions) {\n\t\tconst criteria = [];\n\t\tconditions.forEach(condition => {\n\t\t\tthis._conditions(criteria, condition);\n\t\t});\n\t\tconst joined = criteria.join(' OR ');\n\t\tthis.having(`(${joined})`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a column or expression to order by\n\t * @param {String} column  The column name or expression to sort by. Include DESC or prefix with - to sort descending\n\t * @return {Select}\n\t */\n\torderBy(column) {\n\t\tthis._orderBys.push(column.replace(/^-(.+)/, '$1 DESC'));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sort by the given column, with a map of columns to translate\n\t * @param {String} column  The column name such as \"created_at\" or \"-created_at\" for descending\n\t * @param {Object} [mapNames={}]  Column names to translate from one name to another\n\t * @example\n\t *     query.sortField('-modified_at'); // ORDER BY modified_at DESC\n\t *     query.sortField('created_at', ['created_at'=>'created']); // ORDER BY created\n\t * @return {Select}\n\t */\n\tsortField(column, mapNames = {}) {\n\t\tconst direction = column.slice(0, 1) === '-' ? 'DESC' : 'ASC';\n\t\tcolumn = column.replace(/^-/, '');\n\t\tcolumn = mapNames[column] || column;\n\t\tthis.orderBy(`${column} ${direction}`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Limit results to the given number\n\t * @param {Number} num  The number to limit by\n\t * @return {Select}\n\t */\n\tlimit(num) {\n\t\tthis._limit = Number(num) || 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Fetch results from the given offset\n\t * @param {Number} num  The offset\n\t * @return {Select}\n\t */\n\toffset(num) {\n\t\tthis._offset = Number(num) || 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the offset based on the limit with the given number of pages\n\t * @param {Number} num  The page number\n\t * @return {Select}\n\t */\n\tpage(num) {\n\t\tthis._page = Number(num) || 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Manually escape a value\n\t * @param {*} value  The value to escape\n\t * @return {string}\n\t */\n\tescape(value) {\n\t\treturn mysql.escape(value);\n\t}\n\n\t/**\n\t * Manually escape a value without quotes\n\t * @param {*} value  The value to escape without quotes\n\t * @return {string}\n\t */\n\tescapeQuoteless(value) {\n\t\tconst escaped = mysql.escape(value);\n\t\tif (escaped.slice(0, 1) === \"'\" && escaped.slice(-1) === \"'\") {\n\t\t\treturn escaped.slice(1, -1);\n\t\t}\n\t\treturn value;\n\t}\n}\n","import { Db } from './Db/Db.js';\nimport { Parser } from './Parser/Parser.js';\nimport { Select } from './Select/Select.js';\nexport { Db, Parser, Select };\n"]}